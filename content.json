{"posts":[{"title":"BSDF是否可线性叠加的推导","text":"Linear composition of BSDF? ROBUST MC Chapter 4 &gt; The operator \\(A\\) that provides a linear mapping in a vector space \\(\\mathcal F \\rightarrow \\mathcal F\\) is called a linear operator. \\(Af\\) denotes the application of an operator to a function, resulting another new function. ### Preliminary Light transport operator: \\[ \\mathbf T = \\mathbf K\\mathbf G \\tag{1} \\] Where \\(\\mathbf K\\) is the local scattering operator, \\(L_o = \\mathbf K L_i\\), both \\(L\\) defined in the whole ray space \\(\\mathcal R\\): \\[ (\\mathbf Kh)(\\mathbf{x}, \\omega_o) = \\int_{S^2} f_s(\\mathbf{x}, \\omega_i \\to \\omega_o) \\, h(\\mathbf{x}, \\omega_i) \\, d\\sigma_{\\mathbf{x}}^\\perp(\\omega_i) \\] \\(\\mathbf G\\) is the propagation operator, defining the geometric property of the space, \\(L_i = \\mathbf G L_o\\), which should be symmetric. \\[ (\\mathbf Gh)(\\mathbf{x}, \\omega_i) = \\begin{cases} h(\\mathbf{x}_M(\\mathbf{x}, \\omega_i), -\\omega_i) &amp; \\text{if } d_M(\\mathbf{x}, \\omega_i) &lt; \\infty, \\\\ 0 &amp; \\text{otherwise,} \\end{cases} \\] Now right the light transport equation in operator form: \\[ L = L_e + \\mathbf T L \\] Inverting the operator equation: \\[ \\begin{equation} \\begin{aligned} (\\mathbf I - \\mathbf T)L &amp;= L_e \\\\ L &amp;= (\\mathbf I - \\mathbf T)^{-1} L_e \\end{aligned} \\end{equation} \\] Defining solution \\(\\mathbf S = (\\mathbf I - \\mathbf T)^{-1}\\). Given that \\(\\Vert \\mathbf T \\Vert \\lt 1\\), the inversion can be expanded with Neumann series: \\[ \\mathbf S = (\\mathbf I - \\mathbf T)^{-1} = \\sum^{\\infty}_{i = 0} \\mathbf T^i = \\mathbf I + \\mathbf T + \\mathbf T^2+ \\cdots \\] Light transport can then be expanded as well: \\[ L = L_e + \\mathbf T L_e + \\mathbf T^2 L_e + \\cdots \\tag{2} \\] Derivation Given a scene, with all reflective materials modeling as the accumulation of two BRDFs: \\[ f_r(\\omega_i, \\omega_o) = f_{diffuse}(\\omega_i, \\omega_o) + f_{specular}(\\omega_i, \\omega_o) \\] Meaning that: \\[ (\\mathbf Kh)(\\mathbf{x}, \\omega_o) = \\int_{S^2} (f_{diffuse}(\\mathbf{x}, \\omega_i \\to \\omega_o) + f_{specular}(\\mathbf{x}, \\omega_i \\to \\omega_o)) \\, h(\\mathbf{x}, \\omega_i) \\, d\\sigma_{\\mathbf{x}}^\\perp(\\omega_i) \\] Because of the linearity of integration, the local scattering operator can be decomposed: \\[ (\\mathbf Kh)(\\mathbf{x}, \\omega_o) = ((\\mathbf K_1 + \\mathbf K_2)h)(\\mathbf{x}, \\omega_o) \\] In which \\(\\mathbf K_1\\) and \\(\\mathbf K_2\\) are the diffuse and specular operator respectively: \\[ \\mathbf K = \\mathbf K_1 + \\mathbf K_2 \\tag{3} \\] Let \\(\\mathbf T_1 = \\mathbf K_1 \\mathbf G\\) and \\(\\mathbf T_2 = \\mathbf K_2 \\mathbf G\\), we define the linear accumulation of two BSDF to be: \\[ L^\\prime = \\sum^\\infty_{i = 0} ((\\mathbf T_1 + \\mathbf T_2) \\mathbf G) ^ i L_e \\] Substitute \\((3)\\) into \\((1)\\) we get: \\[ \\mathbf T = (\\mathbf K_1 + \\mathbf K_2)\\mathbf G \\tag{4} \\] Bring \\((4)\\) into \\((2)\\) we get: \\[ L = L_e + ((\\mathbf K_1 +\\mathbf K_2)\\mathbf G)L_e + ((\\mathbf K_1 +\\mathbf K_2)\\mathbf G)^2L_e + \\cdots \\] Intuitively, \\(L^\\prime = L\\) iff the two operator \\(\\mathbf K_1\\) and \\(\\mathbf K_2\\) is strictly orthogonal, such that: \\[ (\\mathbf K_1 \\mathbf K_2h)(\\mathbf{x}, \\omega_o) = 0 \\]","link":"/2024/11/19/BSDF%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BA%BF%E6%80%A7%E5%8F%A0%E5%8A%A0%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"title":"C++：奇异递归模板模式（CRTP）","text":"奇异递归模板（Curiously Recurring Template Pattern，CRTP）正如其名，是一种递归式利用c++模板的设计模式，更一般地被称作F-bound polymorphism，是我最近在开发数学库的时候听闻的一种惯用法。 What is CRTP? CRTP的代码很简单，可以用如下的代码演示： 123456789101112131415template &lt;typename Child&gt; struct Base { void interface() { static_cast&lt;Child *&gt;(this)-&gt;implementation(); }};struct Derived : Base&lt;Derived&gt; { void implementation() { cerr &lt;&lt; &quot;Derived implementation\\n&quot;; }};template &lt;typename ChildType&gt; struct VectorBase { ChildType &amp;underlying() { return static_cast&lt;ChildType &amp;&gt;(*this); } inline ChildType &amp;operator+=(const ChildType &amp;rhs) { this-&gt;underlying() = this-&gt;underlying() + rhs; return this-&gt;underlying(); }}; 父类接收一个子类作为模板参数，子类在实现的时候将自身传入（递归），父类利用这个模板参数将自身静态转换为子类的引用后调用子类的函数。 可以发现，CRTP本质就是静态多态，即：在编译期实现的同名函数的不同行为，在Base类中设置好的interface函数可以根据子类的implementation函数的实现不同来产生不同的行为。听起来是不是和虚函数很像？其实上面这段代码的实现效果和下面的虚函数实现版本代码很像： 1234567struct VBase { void interface() {} virtual void implementation() { cout &lt;&lt; &quot;VBase&quot; &lt;&lt; endl; }};struct VDerived : public VBase { void implementation() override { cout &lt;&lt; &quot;VDerived&quot; &lt;&lt; endl; }}; Why CRTP? 既然和虚函数实现的效果是一致的，并且在模板技术已经相当成熟的当下（如C++20中已经可以使用的concept），为什么还要使用CRTP？简单列举一个例子，比如我要实现一个数学库，如果使用运行时多态来实现向量类Vector，那么代码结构大致如下： 12345678template&lt;typename Type, unsigned Len&gt;struct VectorBase{ virtual void someFunction(){...} ...};struct Vector3: VectorBase&lt;float, 3&gt;{ virtual void someFunction() override {...}}; 需要注意的是，运行时多态是有开销的，熟悉c++虚函数的人应该就能明白，如果我调用一个虚函数，需要查询对象头部的虚函数表来得到实际函数地址，这个寻址的开销对于一个数学库而言是非常巨大的。而如果使用静态多态，则可以使用如下的代码来实现： 1234567891011121314151617181920template &lt;typename ChildType&gt; struct VectorBase { ChildType &amp;underlying() { return static_cast&lt;ChildType &amp;&gt;(*this); } inline ChildType &amp;operator+=(const ChildType &amp;rhs) { this-&gt;underlying() = this-&gt;underlying() + rhs; return this-&gt;underlying(); }};struct Vec3f : public VectorBase&lt;Vec3f&gt; { float x{}, y{}, z{}; Vec3f() = default; Vec3f(float x, float y, float z) : x(x), y(y), z(z) {}};inline Vec3f operator+(const Vec3f &amp;lhs, const Vec3f &amp;rhs) { Vec3f result; result.x = lhs.x + rhs.x; result.y = lhs.y + rhs.y; result.z = lhs.z + rhs.z; return result;} 可以看到，静态多态虽然导致代码复用度相较于运行时多态降低了很多，但是相较于完全手搓，我们可以利用子类实现的operator+来通过CRTP自动添加operator+=，相当于是做到了运行效率与开发效率的相对平衡。 Summary CRTP在80年代被提出，但是至今仍然被广泛使用，虽然今天运行时多态已经相当成熟，但是我们仍然希望能在运行效率和开发效率之间做到平衡，这时CRTP就成为了我们的不二之选：拥有多态的代码复用性的同时可以除去动态多态的runtime开销。 本文相关代码在crtp.cpp 参考资料 奇异递归模板模式(Curiously Recurring Template Pattern) - 吉良吉影的文章 - 知乎","link":"/2022/07/14/C-%EF%BC%9A%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%EF%BC%88CRTP%EF%BC%89/"},{"title":"北邮计算机系统基础 (CSAPP) 期末考试总结","text":"今天结束了计算机系统基础的考试，不得不说北邮的考试还是很水的，基本上老师说的重点都没考 (重定位、符号解析)，但是鉴于总体还是有一定难度，因此在这篇博文里总结一下 题型总结 题型大概分为 3 种，分别是：单选题、判断题、简答题 单选题 没啥难的，对我而言最难的是：一个关于地址对齐的题和一个关于链接的题，注意复习这两个点。 判断题 把书上的课后习题多看看，了解有符号数和无符号数的关系以及几个大数 \\(Tmax\\) \\(Tmin\\) \\(Umax\\)的运算、大小比较即可。 简答题 分数大头，没有捷径可以走，要好好学汇编，熟练掌握各个汇编指令。比较怪的一点是今年最后一个大题考了金丝雀保护，关于数的生成以及数的检验，但是分数占得不多，最为重要的是要熟悉循环以及 C 和汇编的等价转换，如果能把汇编玩的出神入化，那么 90 分应该是可以保底了（前提是其他题能全对），另外，对齐、文件操作各考了一个大题，同样需要着重复习。 重点 关于书上的章节以及考试对应的重要性，如果仅采取本次考试的样本，基本是属于一个及其不均匀的分布，列一个表以供参考（重要、难易程度均从 0-5⭐ 标识，如果没有出现的章节表示几乎没有出现在考试中，加粗的表示是重点）： 章节 重要程度 难易程度 第二章 信息的表示和处理 ⭐⭐⭐⭐ ⭐⭐⭐ 第三章 程序的机器级表示 ⭐⭐⭐⭐⭐ ⭐⭐⭐⭐ 第七章 链接 ⭐⭐ ⭐⭐ 第八章 异常控制流（19 级仅简单说明） ⭐ ⭐ 第十章 系统级 I/O ⭐⭐⭐ ⭐⭐ BUPT 自制，中断 ⭐ ⭐⭐ 复习方法 建议空出一天来做题，我是在考前一个晚上才看到了 Linn 大佬的总结，这里贴上地址 BUPT-CSAPP 期末复习书后参考题节选及评注 其中，转载一些个人感觉很有帮助的东西： 练习题 第 2 章 2.21、2.23、2.24、2.33、2.40、2.44、2.45、2.47、2.54 2.60、2.65、2.67、2.68 第 3 章 3.1、3.2、3.3、3.4（先阅读图 3-5、3-6 指令功能）、3.5、3.6 3.7、3.9、3.15、3.18、3.20、3.26、3.27、3.31、3.32、3.33 3.36、3.37、3.38、3.44、3.45 第 7 章 7.1、7.2、7.4、7.5 第 10 章 10.1、10.2、10.3、10.5 总结 总的来说，这次考试难度很小，目的是要求学生熟练掌握前几章的知识，后几章的知识基本属于“会认就行”的程度，如果只是为了复习没有必要钻牛角尖磕一些很小的知识点，另外如果复习到无法确定的东西建议动手实践。 最后，对于北邮开设这门课的评价是，相较于 CMU 原版的课程，删减了很多东西，要求学生能完全掌握的很少，因此几个 lab 一定要好好做，介于本学期本身课程压力也比较大，这门课只有 1.5 学分也是情理之中。最后希望这篇博文能帮到一些同学，考试加油。 PS 欢迎加入 csapp/计网/计组/操作系统 四合一 qq 群交流相关课程/考试/技术（大部分是北邮 19-级的学生），群号1049205600。","link":"/2020/12/24/CSAPP%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"FastAPI部署PyTorch CPU inference项目内存泄漏以及解决方案","text":"起因 最近需要在一个2c4g的一个服务器上做VITS-fast-finetuning项目的边缘部署，VITS算一个不大不小的模型，实测下来服务器的内存只有3.6G，刨开乱七八糟的服务也就只剩下少得可怜的2G左右内存可用，因此需要相当地精打细算才能得到比较好的效果。 前端没啥好说的，自己和copilot合作了一下撸了一个又不是不能用的，之后就轮到重量级的后端登场了。 还在漏还在漏 首先我们的需求和一些现实情况如下： 服务器的内存和CPU资源都相当吃紧，基本每一次TTS请求都能把两核的CPU吃满 我希望每一次请求响应都够快，最简单的解决办法就是对模型（tts_fn）进行caching，相应的需要trade off一些内存 根据上一条需求，我们最好不要用subprocess来进行模型的推理，即使不考虑subprocess本身的开销，我们也不希望每一次请求都要重新加载模型 需求对应的代码其实很简单，但是最后我使用Gunicorn + Uvicorn worker + FastAPI进行部署的时候出问题了：我手上有5个模型，但是只要请求数一多，整个服务器就会直接死掉，这是怎么会事呢？ 首先我们刨掉几个模型，剩下三个，然后把worker给减到一个。发现运行几次之后，内存占用不停增长，直到把3.6G全部吃满，服务器没有响应，连SSH都会卡死（这里建议不要急，等个几分钟操作系统就会直接把内存清理掉）。 问题定位 首先我们假设内存泄漏不出在VITS-fast-finetuning身上（实际上我检查了一遍也确实没有），一般来说简单的python web代码也没法写出内存泄漏的问题。使用开箱即用的memory_profiler进行内存分析：这个库提供了非常方便的memory_profiler.profile装饰器，可以直接在函数上使用，然后就可以得到函数单步的内存占用情况。 给每一个有嫌疑的函数都打上了@profile，发现问题出在了一个卷积层Conv1D上（偷懒图里不是同一次请求的调用栈，不过无伤大雅）： 每个卷积层每次调用都会增加15-30M左右的内存占用，不幸的是模型中对该卷积层进行了循环调用，每一次请求下来整个服务器内存占用都会增加10M左右，在htop中查看也基本一致。 漏水容易补水难 在进行profile之前我先上网搜了一下FastAPI+Pytorch+内存泄漏相关的问题，得到的答案无非是： 这是worker内存的问题，使用async进行异步处理：实测对于我的问题没有任何帮助 使用subprocess进行模型推理：不符合需求，pass 使用jemalloc替代glibc：具体的方法是安装jemalloc并手动指定环境变量LD_PRELOAD=LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2，根据测试可以大幅减少内存的占用（在加载一个模型的时候总内存占用从3G+降低到了2.6G+左右），但是随着请求的增加，内存占用还是会不断增加，pass 解决方案 Damn, who knows! 在发现问题出在卷积层后，找到了这个issue：Memory leak in Conv1d，就是这个！这个issue在23年9月提出&amp;&amp;解决了，但是看样子服务器上的pytorch并没有实装这个fix，但是一个回复中提到了一个解决方案： When our validation team tried to reproduce it on CPU, all the to('cuda') has been changed to to('cpu'). As it is a case with dynamic shape inputs, the primitive and primitive description cache has made the memory increase at the beginning when it hasn't reached the maximum cache capacity size. By setting the below environment variables to decrease the cache capacity, the memory won't increase anymore: ONEDNN_PRIMITIVE_CACHE_CAPACITY=0 LRU_CACHE_CAPACITY=1 设置这两个环境变量之后，内存占用果然不再增加，翻译成人话就是： 在动态shape的输入下，pytorch会缓存一些东西，primitive和primitive缓存会在未达到最大缓存大小的时候不断增加，通过设置这两个环境变量可以减少缓存的容量，使得内存占用不再增加直到服务器死掉。 Gunicorn：哈哈，没想到吧 这个办法对于Uvicorn直接运行是生效的，但是我在服务器上直接跑了一个systemd service的gunicorn，前面说的东西在这玩意上一用上好像diao用没有，这是怎么会事呢？ 探查后发现Gunicorn似乎不会老实地把自己的环境变量传递给worker子进程，需要在配置文件中手动指定： 1raw_env = [&quot;ONEDNN_PRIMITIVE_CACHE_CAPACITY=0&quot;, &quot;LRU_CACHE_CAPACITY=1&quot;, &quot;LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2&quot;] And finally, its works fine. 省流总结 设置环境变量ONEDNN_PRIMITIVE_CACHE_CAPACITY=0和LRU_CACHE_CAPACITY=1，可以减少pytorch的缓存容量，避免内存泄漏（伪），此外推荐使用jemalloc替代glibc，可以减少内存占用。","link":"/2024/02/14/FastAPI%E9%83%A8%E7%BD%B2PyTorch-CPU-inference%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Line, and more than line","text":"在计算机图形学的几何分支中，直线和曲线都属于隐式表示(Implicit Represent)的几何组件，我们需要一些高效的方式将这些图形以较高的质量绘制到屏幕上。 布雷森汉姆算法 虽然是相对朴素的算法，但是布雷森汉姆算法至今仍有着较高的使用率。 算法的基本想法是通过斜率来不断累积一个error，每当error的值超过一个阈值(0.5)的时候就在另一个方向上进行长度为1像素的前进，最终绘制出一根在屏幕上连续的直线。 核心代码如下： 12345678910111213141516171819202122232425262728int x0 = line[0][0], y0 = line[0][1], x1 = line[1][0], y1 = line[1][1];bool steep = abs(y1 - y0) &gt; abs(x1 - x0);if (steep) { swap(x0, y0); swap(x1, y1);}if (x0 &gt; x1) { swap(x0, x1); swap(y0, y1);}float dx = x1 - x0;float dy = abs(y1 - y0);float err = 0;float derr = dy / dx;int ystep = y0 &lt; y1 ? 1 : -1;int y = y0;for (int x = x0; x &lt;= x1; x++) { if (steep) { image.set_white_alpha(y, x); } else { image.set_white_alpha(x, y); } err += derr; if (err &gt; 0.5f) { y += ystep; err -= 1.0f; }} 布雷森汉姆算法允许我们以较高的效率(去浮点化)地绘制一条效果尚可的直线，不过缺点也很明显，绘制出的直线上分布着许多锯齿，如果希望得到一条质量较高的直线，则需要用到另一个算法。 吴小林算法 布雷森汉姆算法虽然可以让我们绘制出连续的直线，但是效果却有些不忍直视，曲线的四周遍布着各种锯齿 使用布雷森汉姆算法绘制的直线 使用吴小林算法绘制的直线 吴小林算法通过直线周围绘制一些透明度非1的像素来实现直线的平滑化。核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162auto fpart = [](float x) { return x - floorf(x); };auto rfpart = [&amp;fpart](float x) { return 1 - fpart(x); };int x0 = line[0][0], y0 = line[0][1], x1 = line[1][0], y1 = line[1][1];bool steep = abs(y1 - y0) &gt; abs(x1 - x0);if (steep) { swap(x0, y0); swap(x1, y1);}if (x0 &gt; x1) { swap(x0, x1); swap(y0, y1);}float dx = x1 - x0;float dy = abs(y1 - y0);float gradient = dy / dx;if (dx == 0.0) { gradient = 1.0;}int xend = round(x0);int yend = y0 + gradient * (xend - x0);float xgap = rfpart(x0 + 0.5f);int xpxl1 = xend;int ypxl1 = (int)yend;if (steep) { image.set_white_alpha(ypxl1, xpxl1, rfpart(yend) * xgap); image.set_white_alpha(ypxl1 + 1, xpxl1, fpart(yend) * xgap);} else { image.set_white_alpha(xpxl1, ypxl1, rfpart(yend) * xgap); image.set_white_alpha(xpxl1, ypxl1 + 1, fpart(yend) * xgap);}float intery = yend + gradient;xend = round(x1);yend = y1 + gradient * (xend - x1);xgap = fpart(x1 + 0.5);int xpxl2 = xend;int ypxl2 = (int)(yend);if (steep) { image.set_white_alpha(ypxl2, xpxl2, rfpart(yend) * xgap); image.set_white_alpha(ypxl2 + 1, xpxl2, fpart(yend) * xgap);} else { image.set_white_alpha(xpxl2, ypxl2, rfpart(yend) * xgap); image.set_white_alpha(xpxl2, ypxl2 + 1, fpart(yend) * xgap);}// main loopif (steep) { for (int x = xpxl1 + 1; x &lt;= xpxl2 - 1; x++) { image.set_white_alpha((int)(intery), x, rfpart(intery)); image.set_white_alpha((int)(intery) + 1, x, fpart(intery)); intery = intery + gradient; }} else { for (int x = xpxl1 + 1; x &lt;= xpxl2 - 1; x++) { image.set_white_alpha(x, (int)(intery), rfpart(intery)); image.set_white_alpha(x, (int)(intery) + 1, fpart(intery)); intery = intery + gradient; }} 总结 直线绘制其实并不是计算机图形学中相关知识的直接体现，但是属于是一个非常有意思的话题，所以出了一篇博客来说说。","link":"/2021/09/12/Line-and-more-than-line/"},{"title":"MIPS五段流水处理器I 顺序实现","text":"尝试使用 Verilog 实现一个 mips 五段流水处理器。 MIPS 指令集 MIPS 指令集分为三类，总共 31 条，分别是 I 型 指令内容中带有立即数 最多使用两个寄存器 Op 字段用于区别不同指令 J 型 长跳转类型 有且仅有一个立即数 Op 字段用于区别不同指令 R 型 仅使用寄存器的指令 Op 字段为 0，使用 funct 字段区别 这三种指令的具体划分以及内容参照这篇博客, 本文中不再赘述。 流水线划分 经典的五段流水线划分为 取指 Fetch 从 PC 程序计数器指向的地址中取出指令 放入 IR 指令寄存器中 PC += 指令长度 译码 Decode 根据 IR 中的指令内容，得到其所需要的 源操作数(寄存器) 目标操作数寄存器 执行 Execute 将源操作数(对应的寄存器)加载进 ALU，然后将对应的运算结果保存进目标操作数寄存器 访存 Memory (仅针对 load/store 指令) load: 从存储器中读出 ALU 计算出的有效地址存储的数据 store: 将寄存器中的数据输入 ALU 计算出的有效地址中 写回 Write Back (仅针对除 store 以外的指令) load: 将读出的数据存储到目标寄存器中 其他指令: 将 ALU 计算出的结果输出到目标寄存器中 稍微多提一句的是，由于我们想要首先制作的是顺序处理器，因此这 5 个步骤中很多地方是没有必要的，比如更新 PC 可以放在最后一步，但是因为我们希望能给流水线寄存器预留拓展，因此还是采用这样符合流水线的设计来制造我们的 cpu。 基本设计图 我们使用自顶向下的设计方法来设计我们的系统，得到的草图如下： 图片是我自己画的，可能比较草率，具体的设计可以参照《CSAPP》一书 P302 的这张图 因此我们可以得到需要的几个基本模块的划分： 控制器 用于控制传入、传出信号 作为顶层原件存在 RAM(严格来说不能算为 cpu 的一部分) 使用冯诺依曼体系结构，同时存储数据和指令 寄存器组 流水线寄存器组 用于存储流水线过程中产生的各种信号和数据，对于用户不可见 内部寄存器组 用于存储对于用户可见的寄存器 五大单元，用于处理各个阶段 取指单元 译码单元 执行单元（主体构成为 ALU） 访存单元 写回单元 使用 verilog 的模块化设计，我们正好得到了一共 9 个模块，我们接下来的任务即设计这几个模块的具体输入以及输出，这里我们使用大写字母来标识某个阶段的输出，小写字母来标识上个阶段的输入。 模块设计 模块名称 输入 输出 F 取指单元 ram_in: 从 ram 接入的指令数据 F_IR: 指令F_PC: 新的程序计数器值 D 译码单元 f_ir: 指令 D_src: 源寄存器组 D_dst: 目标寄存器组 D_alufun: 运算种类 D_icode: 指令类型 E 执行单元 d_src: 译码得到的输入 d_alufun: 译码得到的运算种类 d_dst d_icode E_val: 执行单元得到的运算结果 D_dst: 目标寄存器组 D_icode M 访存单元 e_val: 执行单元得到的运算结果 d_src (store 指令): 放入存储器的数据 d_dst: 传给下一步 d_icode M_val: 从内存中读出的数据 E_val: 传给下一步 D_dst: 目标寄存器组 D_icode W 写回单元 e_val: ALU 运算结果 d_dst: 目标寄存器组 m_val: 内存中读出的数据 d_icode 根据上文的分析，发现由于有流水线寄存器这一机制的存在，不需要设置一个专门的控制器来进行相关的控制，每一阶段的运算只取决于上一阶段流水线寄存器的结果，这样一方面简化了设计，另一方面也让我们以后从顺序向流水线转化更加方便，下一步则是各个模块的 verilog 具体实现。 To be continue...","link":"/2021/01/14/MIPS%E4%BA%94%E6%AE%B5%E6%B5%81%E6%B0%B4%E5%A4%84%E7%90%86%E5%99%A8I-%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0/"},{"title":"NSCSCC2021后记","text":"NSCSCC2021 终于结束了，经过了一个月的奋战，虽然结果比较可惜只有一个三等奖，但是过程中还是有不少值得记录的东西。 先上个仓库地址：HectorMIPS Chisel3 or SystemVerilog 在一开始技术选型的时候，我有纠结过是使用SystemVerilog还是Chisel，前者是被龙芯杯往年参赛选手广泛使用的编程语言，后者是被香山团队所Pick的语言。Which is better? 问题的结果并不重要，最后选择了chisel是基于我上个暑假已经使用verilog实现过一个MIPS的五级流水CPU（没带中断以及例外，指令集也高度阉割），However体验并不是很好，于是这次便大胆地尝试了chisel作为开发语言（虽然事实证明我们因此踩了不少坑）。 紧凑的日程 比赛大概在4或者5月开始报名，具体时间我不大记得清了，但是我们最终开始着手制作CPU已经是7月初的事了——离比赛初赛提交还有一个月，时间非常捉急，因此只能赶鸭子上架式地制作我们的参赛作品。 我主要负责流水线的部分，花费了大概两周时间完成了一个可以通过功能测试和性能测试的单发射版本，并且在23号的时候通过了系统测试。这个时候性能分因为没有cache，测试出来大概只有不到1的水准，同时由于参照龙芯的那本书上的设计问题，我们的频率也只能达到70MHz左右。不过此时的我把大部分的问题归于是没有cache，于是紧锣密鼓地开始了双发射版本的迁移。 惊险的提交 我是在提交的前一晚通了宵，打算第二天提交的时候测试一下直接交一个稳定版本上去（这个时候我们的双发射以及完成了移植，并且将频率提升在60MHz左右），在晚上将近8-9点的时候，离提交还有三个小时左右，我们最终得到了一个分数在40分，72MHz的版本。虽然一天前我们已经通过了系统测试，但是我决定还是generate再跑一次，结果一跑就直接出了问题，console整个挂掉没反应。我一脸懵逼，心里已经预想到估计是cache那块的问题了，在一番struggle之后，还是交了一个没有通过系统测试的版本，这个时候相当于我们的总分直接掉了15分，心里是相当的绝望。不过最后积分表一出来的时候，发现我们队竟然还是能以倒数第一的成绩排在决赛的名单上。 总结 后面的系统移植因为种种原因，几乎没有成果。 To be continued...","link":"/2021/08/28/NSCSCC2021%E5%90%8E%E8%AE%B0/"},{"title":"PBR论文实现：Marschner&#39;s&#x2F;d&#39;Eon Hair Model","text":"在完成GAMES101大作业的时候，选择了Marchner的毛发模型的实现，先后参考了两篇论文，总算是做出来像个东西了。 我阅读的第一篇论文是《Light Scattering from Human Hair Fibers》，这篇文章属于是现在的毛发渲染的开山鼻祖了。 这篇论文开创性地提出了毛发的表皮含芯的模型： 作者认为人类的毛发不是单纯的一个柱状模型（Kajiya模型），而是表皮(cuticle)加上柱芯(cortex)的组合。同时，将毛发的不同颜色归因于柱芯对于不同波长光的吸收率不同，从而导致毛发出现不同的颜色。很重要的，这个模型将光线从单纯的反射（brdf）拓展为了多个不同的类别（bcsdf），其中Marschner的这篇论文着重强调了其中的三个组成项：R、TT、RTR，R代表一次反射（reflection），T代表一次在柱芯中的传播（transmission），这里我们也可以得到，R项是没有受到吸收的，所以R项应该是造成高光的项。 因为要直接讨论立体空间中的bcsdf会十分麻烦，因此研究者十分聪明地将一次入射投射到azimuthal和longitudinal两个方向，分别对应公式中的\\(N_p\\)和\\(M_p\\)两项，两项相乘的结果便是一个完整的入射出射得到的bcsdf。Marschner文章中的公式如下： \\[S(\\phi_i, \\theta_i;\\phi_r,\\theta_r) = M(\\theta_i, \\theta_r)N(\\eta'(\\theta_d);\\phi_i,\\phi_r)/\\cos^2(\\theta_d)\\] 需要注意的是，因为这里有R、TT、TRT三项，对应的S也有三项，相加得到最终的答案，完整公式如下： 有了基本的思想，接下来就是对于各个子项求解了。 Longitudinal散射方程 在这个part中，我们主要和\\(\\theta\\)项打交道，也就是我们研究和发丝径向不同夹角时产生的散射结果，有趣的是，Marschner模型的作者通过实验测量发现这个分布和高斯分布是近似的，于是我们可以通过一个标准高斯函数去逼近这个结果： \\[M_p(\\theta_h)=g(\\beta_p; \\theta_h - \\alpha_p)\\] 这里的\\(\\beta\\)和\\(\\alpha\\)分别代表longitudinal方向的width（标准差）和shift（偏移），正好带入标准高斯方程的两个参数中。 在我阅读的第二篇论文《An Energy-Conserving Hair Reflectance Model》中，作者没有单纯的使用高斯分布，其指出使用高斯分布会导致渲染结果不遵守能量守恒（丢失大概15%），于是选用了一个符合能量守恒结果的函数： 这样得到的结果更为科学，但是在我的实现中，为了偷懒实现方便，还是选择了Marschner模型中的标准高斯分布。 对应代码： 123456// M term, we'll simply use gaussian distribution hereFloat Mp[3];for (int i = 0; i &lt; 3; i++){ Mp[i] = gaussian_function(beta[i], theta_h - alpha[i]);} Azimuthal散射方程 Marschner模型中对于\\(N_p\\)项使用了一个带微分的求和公式来准确计算散射波瓣的能量： \\[N_p(p, \\phi) = \\sum_rA(p, h(p,r,\\phi))|2\\frac{d\\phi}{dh}(p, h(p,r,\\phi))|^{-1}\\] 根据折射反射的几何关系可以有如下的角度计算： \\[\\phi(p, h) = 2p\\gamma_t-2\\gamma_i+p\\pi\\] 再加上菲涅尔项和柱芯吸收： \\[A(p,h)=(1-F(\\eta',\\eta'',\\gamma_i))^2F(\\frac{1}{\\eta'}, \\frac{1}{\\eta''}, \\gamma_t)^{p-1}T(\\sigma'_a,h)^p\\] 也就是说我们需要通过第二个公式求微分然后代入第一个公式，同时利用折射法则计算\\(\\gamma_t\\)和\\(\\gamma_i\\)的关系，很关键的，对于入射出射角，想要计算两个角度之间的关系需要利用三角函数，不利于计算，于是我们可以通过多项式拟合，再求根。但是这样要求出\\(p=0,1\\)的时候的解还算简单，求到\\(p\\ge 2\\)之后，多项式的指数暴涨，要求根不太现实，不适合用于计算机求解。 于是在d'Eon11的文章里便提出了另一种方法求解\\(N_p\\)，那就是使用积分，通过从-1到1的h项的入射\\(dh\\)积分起来，模拟在出射方向的波瓣分布，来得到一个方便数值计算与预积分的解： \\[N_p(\\phi) = \\frac{1}{2}\\int^1_{-1}A(p,h)D_p(\\phi - \\Phi(p,h))dh\\] 同时d'Eon11这篇文章中也粗略的描述了预积分的做法：将\\(\\phi\\)和\\(\\cos\\theta_d\\)作为两个参数构建一个二维的预计算插值表，然后运行时直接根据获取的对应的参数进行插值即可！注意，这里的积分使用的是高斯-勒让德定积分法，简单来说就是对于\\(x\\in[-1,1]\\)的积分，选取-1到1之间的若干点，再给予各个点不同的权重，将这些点带入方程中求值之后再求和即可得到定积分的近似解。 这个公式中，使用了Gaussian Detector函数\\(D_p\\)来模拟出射方向上的光线分布： \\[D_p(\\phi) = \\sum^{\\infty}_{k=-\\infty}g(\\beta_p;\\phi-2\\pi k)\\] 同样的，这个函数也是可以对\\(\\phi\\)进行预积分的： 1234567891011121314151617181920212223Float gaussian_detector(Float b, Float phi) const{ Float result = 0; Float x, y, delta; int k = 0; constexpr Float M_PIx2 = M_PI * 2; do { x = gaussian_function(b, phi - M_PIx2 * Float(k)); y = gaussian_function(b, phi + M_PIx2 * Float(k + 1)); delta = x + y; k++; result += x + y; } while (delta &gt; 1e-4f); return result;}for (int i = 0; i &lt; BCSDF_TERM_NUMBER; i++){ for (int j = 0; j &lt; GAUSSIAN_DETECTOR_SAMPLES; j++) { GD_table[i][j] = gaussian_detector(beta[i], j / (GAUSSIAN_DETECTOR_SAMPLES - 1.0f) * M_PI * 2.0f); }} 总体对应的预积分代码就不贴出来了，参考了Tungsten中的代码，代码链接如下：Marschner's Hair Model。 这里有一点需要注意的是，d'Eon11的文章里由于使用了新的\\(M_p\\)函数，所以对比的时候将原来的\\(M_p\\)的R项替换为了\\(M_R=g(\\beta_R,2\\theta_h)\\)来避免能量的翻倍。 最后得到的结果如下： 反思与思考 相比起Tungsten的渲染结果，使用我编写的bcsdf渲染得到的头发显然并不真实，很大一部分原因是因为我目前使用的重要性采样函数是一个球面的uniform采样，但是d'Eon 13文章中提出了一种新的采样策略我暂时还没有仔细研读，之后可能会考虑实现。 附录：Mitsuba的编译和配置 mitsuba的官方仓库中是这么介绍自己的： Mitsuba is a research-oriented rendering system in the style of PBRT, from which it derives much inspiration. It is written in portable C++, implements unbiased as well as biased techniques, and contains heavy optimizations targeted towards current CPU architectures. Mitsuba is extremely modular: it consists of a small set of core libraries and over 100 different plugins that implement functionality ranging from materials and light sources to complete rendering algorithms. In comparison to other open source renderers, Mitsuba places a strong emphasis on experimental rendering techniques, such as path-based formulations of Metropolis Light Transport and volumetric modeling approaches. Thus, it may be of genuine interest to those who would like to experiment with such techniques that haven't yet found their way into mainstream renderers, and it also provides a solid foundation for research in this domain. The renderer currently runs on Linux, MacOS X and Microsoft Windows and makes use of SSE2 optimizations on x86 and x86_64 platforms. So far, its main use has been as a testbed for algorithm development in computer graphics, but there are many other interesting applications. Mitsuba comes with a command-line interface as well as a graphical frontend to interactively explore scenes. While navigating, a rough preview is shown that becomes increasingly accurate as soon as all movements are stopped. Once a viewpoint has been chosen, a wide range of rendering techniques can be used to generate images, and their parameters can be tuned from within the program. 闫令琪大大也评价Mitsuba2为最好的非商业领域渲染器，但是第一代mitsuba和第二代mitsuba的breaking change让我不得不选用第一代mitsuba来完成这篇论文的实现。 在我尝试了多个平台之后，发现最适合mitsuba1的编译安装环境还是Debian/Ubuntu等Linux操作系统上，版本不需要太过纠结。 首先从Github上拉取源代码： 1git clone https://github.com/mitsuba-renderer/mitsuba.git 重点：切换到支持python3和scons3的分支上 1git checkout scons-python3 安装对应依赖 123456sudo apt-get install build-essential scons mercurial \\ libpng-dev libjpeg-dev \\ libilmbase-dev libxerces-c-dev libboost-all-dev \\ libopenexr-dev libglewmx-dev libxxf86vm-dev \\ libpcrecpp0v5 libeigen3-dev libfftw3-devpip install scons==3.0.4 提取config 1cp build/config-linux-gcc.py config.py 在根目录下使用scons进行编译 1scons -j10 这里需要说明的是，scons编译出来的版本即为开了-O3优化的版本，不需要额外指定flag。 与此同时，由于mitsuba有些年久失修，可能编译过程中会报一些奇奇怪怪的错，可以参考mitsuba仓库的issue一个一个对应修掉。 设置环境变量 1source setpath.sh 之后就可以在dist文件夹下面运行mitsuba来进行渲染了。","link":"/2021/12/26/PBR%E8%AE%BA%E6%96%87%E5%AE%9E%E7%8E%B0%EF%BC%9AMarschner-s-d-Eon-Hair-Model/"},{"title":"PBR论文简读：A Practical Model for Subsurface Light Transport","text":"导语 离线环境下进行真实感渲染的时候，会有各种散射材质，比如人类皮肤、硅胶等。从外观上看，这类材质的通性在于都有一种“透光”的感觉，简单的使用brdf创造出来的材质往往显得很生硬，因此Jensen'01的这篇论文给出了一个实际的次表面散射（subsurface scattering）bxdf来实现这种材质。 理论 BRDF理论假设材质光的进入和离开的起、终点一致，本质上是对BSSRDF的一种近似\\(x_o = x_i\\)，并且给出的积分公式也是简单地在半球面上进行积分，BSSRDF则考虑的是出、入射点不同时，对于区域\\(A\\)内所有入射光线的radiance的半球面积分： \\[L_o = \\int_A\\int_{2\\pi}S\\cdot L_i\\cdot (\\vec n\\cdot \\vec {\\omega_i})d\\omega_i dA(x_i)\\] 我们需要的就是文章给出的BSSRDF：\\(S\\)项，这里Jensen'01的论文将次表面散射的BSSRDF拆解成了Diffusion Approximation和Single Scattering两个term求和。前者基于的是：通过观察，发现高度散射的介质的光线分布有着各项同性的特征（即使入射光和相位函数是高度各向异性的），后者论文中并没有给出一个拆分的理由，而是从前人的论文中得到的BRDF扩展成为了BBSSRDF，并且后者当且仅当出、入射光的折射发生相交时才会出现，个人理解是对于diffuse的一个specular补偿。 推导 在介质中，光线的传播被我们使用辐射传播方程所描述： \\[(\\vec{\\omega} \\cdot \\vec{\\nabla}) L(x, \\vec{\\omega})=-\\sigma_{t} L(x, \\vec{\\omega})+\\sigma_{s} \\int_{4 \\pi} p\\left(\\vec{\\omega}, \\vec{\\omega}^{\\prime}\\right) L\\left(x, \\vec{\\omega}^{\\prime}\\right) d \\omega^{\\prime}+Q(x, \\vec{\\omega})\\] 我们分别使用三个参数：吸收系数\\(\\sigma_\\alpha\\), 散射系数\\(\\sigma_s\\)（这两者的和定义为消散系数\\(\\sigma_t\\)）和相位函数\\(p(\\vec w, \\vec w')\\)来描述介质的属性，其中相位函数可以看作是描述在介质中一点的光线散射的角度分布[1]的函数，同时文章假设这个函数已经normalize了（对于整个球面积分为1）。紧接着定义了平均余弦函数\\(g\\)用来描述相位函数的性质\\(g=\\int_{4 \\pi}\\left(\\vec{\\omega} \\cdot \\vec{\\omega}^{\\prime}\\right) p\\left(\\vec{\\omega} \\cdot \\vec{\\omega}^{\\prime}\\right) d \\omega^{\\prime}\\)：大于0说明散射大部分是前向的，小于0则是反向的，等于零说明在球面上均匀分布（各向同性）。对于一个理想的无穷小光束，radiance根据传播距离\\(s\\)的衰减定义为指数级的：\\(L_{r i}\\left(x_{i}+s \\vec{\\omega}_{i}, \\vec{\\omega}_{i}\\right)=e^{-\\sigma_{t} s} L_{i}\\left(x_{i}, \\vec{\\omega}_{i}\\right)\\)。这样，一阶的散射就可以被作为次级的体积光源使用，可以得出一个点在\\(x\\)处接收到周围某个点发射的irradiance：\\(Q(x, \\vec{\\omega})=\\sigma_{s} \\int_{4 \\pi} p\\left(\\vec{\\omega}^{\\prime}, \\vec{\\omega}\\right) L_{r i}\\left(x, \\vec{\\omega}^{\\prime}\\right) d \\omega^{\\prime}\\)。接下来就可以对\\(x\\)点的辐射传播方程的散射参数\\(\\omega'\\)进行积分，获得周围所有光对\\(x\\)点的影响，将两个irradiance，\\(\\phi(x)\\)和\\(\\vec E(x)\\)联系了起来： \\[\\vec{\\nabla} \\cdot \\vec{E}(x)=-\\sigma_{a} \\phi(x)+Q_{0}(x)\\] 这里引入的零阶源\\(Q_{0}(x)=\\int_{A_{\\pi}} Q(x, \\vec{\\omega}) d \\omega\\)就是前文提到的次级光源，同时将更高阶的源1定义为\\(\\vec{Q}_{1}(x)=\\int_{4 \\pi} Q(x, \\vec{\\omega}) \\vec{\\omega} d \\omega\\)。 Diffusion Approximation 上一节说到，diffusion被看作是各向同性的，论文中就直接利用这个特性把radiance展开成了radiant fluence和vector irrandiance和（这两个本质上都是irradiance），除以了球体单位角的总和\\(4\\pi\\)即是\\(Le\\)（原文里面说这两个的常数系数是由fluence和vector irradiance的定义决定的）： \\[L(x, \\vec{\\omega})=\\frac{1}{4 \\pi} \\phi(x)+\\frac{3}{4 \\pi} \\vec{\\omega} \\cdot \\vec{E}(x) \\tag{1}\\] 将这个式子代入辐射传播方程，类似的，对\\(\\omega\\)进行积分，得到的结果式：\\(\\vec{\\nabla} \\phi(x)=-3 \\sigma_{t}^{\\prime} \\vec{E}(x)+\\vec{Q}_{1}(x)\\)，其中\\(\\sigma_{t}^{\\prime}=\\sigma_{s}^{\\prime}+\\sigma_{a} \\text { where } \\sigma_{s}^{\\prime}=\\sigma_{s}(1-g)\\)，然后将上式带入上上个等式，得到经典的diffusion方程： \\[D \\nabla^{2} \\phi(x)=\\sigma_{a} \\phi(x)-Q_{0}(x)+3 D \\vec{\\nabla} \\cdot \\vec{Q}_{1}(x)\\] 在一个无限大的介质里的各项同性点光源，上式\\(x\\)点的irradiance有一个简单的解如下： \\[\\phi(x)=\\frac{\\Phi}{4 \\pi D} \\frac{e^{-\\sigma_{t r} r(x)}}{r(x)}\\] 当考虑传输介质是处于有限区域的时候，就需要考虑边界区域（出射）的情况，这里论文考虑边界只有出射的情况，也就是入射的flux为0：\\(\\int_{2 \\pi_{-}} L\\left(x_{s}, \\vec{\\omega}\\right)\\left(\\vec{\\omega} \\cdot \\vec{n}\\left(x_{s}\\right)\\right) d \\omega=0\\)（法线向外，但是在内部积分），使用公式(1)展开有： \\[\\phi\\left(x_{s}\\right)-2 D(\\vec{n} \\cdot \\vec{\\nabla}) \\phi\\left(x_{s}\\right)=0 \\tag{3}\\] 但是上面的公式只考虑了surface两边IOR相等的情况，对于两边不等的情况，在表面处会发生反射，根据菲涅尔公式可以计算出平均的菲涅尔漫反射系数\\(F_{dr}\\)，具体方法就是对菲涅尔系数与视线、法线的夹角余弦做积分。可以用菲涅尔公式做一个解析的解，但是论文里面选择了一个基于多项式的近似： \\[F_{d r}=-\\frac{1.440}{\\eta^{2}}+\\frac{0.710}{\\eta}+0.668+0.0636 \\eta\\] 根据前文的净通量为0，同样的有： \\[\\phi\\left(x_{s}\\right)-2 D(\\vec{n} \\cdot \\vec{\\nabla}) \\phi\\left(x_{s}\\right)=F_{d r}\\left[\\phi\\left(x_{s}\\right)+2 D(\\vec{n} \\cdot \\vec{\\nabla}) \\phi\\left(x_{s}\\right)\\right]\\] 化简： \\[\\phi\\left(x_{s}\\right)-2 A D(\\vec{n} \\cdot \\vec{\\nabla}) \\phi\\left(x_{s}\\right)=0\\tag{4}\\] 实际上观察这个公式和(3)的区别也仅仅在于多了一个平均漫射菲涅尔系数相关的\\(A\\)。这样我们就可以根据边界的值，通过出射的radiance（\\(\\vec n \\cdot \\vec E(x_s)\\)等于表面的通量梯度）除以入射的flux计算出BSSRDF diffusion approximation了： \\[R_{d}(r)=-D \\frac{(\\vec{n} \\cdot \\vec{\\nabla} \\phi)\\left(x_{s}\\right)}{d \\Phi_{i}\\left(x_{i}\\right)}\\] 但是有限介质的辐射方程没有精确的解析解，为了简化模型，论文引用了“双极子”的方法模拟体积光源分布，对于次级体积光源，引入了两个点光源： 其中正光源在surface下，负光源在surface上，用来模拟光的衰减效应，两者总体的fluence满足： \\[\\phi(x)=\\frac{\\Phi}{4 \\pi D}\\left(\\frac{e^{-\\sigma_{t r} d_{r}}}{d_{r}}-\\frac{e^{-\\sigma_{t r} d_{v}}}{d_{v}}\\right)\\] 这样，在有限介质下的边界条件也得到了，紧接着就可以带入之前的公式求出\\(R_d(r)\\)了 \\[\\begin{aligned} R_{d}(r) &amp;=-D \\frac{\\left(\\vec{n} \\cdot \\vec{\\nabla} \\phi\\left(x_{s}\\right)\\right)}{d \\Phi_{i}} \\\\ &amp;=\\frac{\\alpha^{\\prime}}{4 \\pi}\\left[\\left(\\sigma_{t r} d_{r}+1\\right) \\frac{e^{-\\sigma_{t r} d_{r}}}{\\sigma_{t}^{\\prime} d_{r}^{3}}+z_{v}\\left(\\sigma_{t r} d_{v}+1\\right) \\frac{e^{-\\sigma_{t r} d_{v}}}{\\sigma_{t}^{\\prime} d_{v}^{3}}\\right] \\end{aligned}\\] Update 2022-5-12 在实现本论文算法的时候发现这个\\(R_d(r)\\)的式子是有问题的，第二行中括号前后两个式子的量纲是不一样的（后面的式子多了一个\\(z_v\\)，会导致结果与实际产生10的指数级别的误差，正确的公式应该参照d'Eon的A better dipole中给出的公式（看了这么多实现竟然没有人指出这个问题，有点匪夷所思了））。 可以看出来，\\(R_d\\)项实际上是只与散射材料本身和双极子与表面距离相关的函数（非严格意义上的反比例，这样就给出了一个很好的性质，让我们在做BSSRDF积分的时候不需要完整地考虑整个surface，而是主要对临近的表面积分即可），进而可以求出BSSRDF中的diffusion term： \\[S_{d}\\left(x_{i}, \\vec{\\omega}_{i} ; x_{o}, \\vec{\\omega}_{o}\\right)=\\frac{1}{\\pi} F_{t}\\left(\\eta, \\vec{\\omega}_{i}\\right) R_{d}\\left(\\left\\|x_{i}-x_{o}\\right\\|\\right) F_{t}\\left(\\eta, \\vec{\\omega}_{o}\\right)\\] 这一项主要是代表了光线在介质中多次散射产生的衰减。 Single Scattering 论文中还专门将一次散射拆成了一个单独的项\\(S^{(1)}\\)提了出来，这里个人暂时无法理解这么做的理论依据，只能理解为单次散射无法看作各向同性的新光源，而是作为一个specular项存在： \\[\\begin{aligned} L_{o}^{(1)}\\left(x_{o}, \\vec{\\omega}_{o}\\right) &amp;=\\sigma_{s}\\left(x_{o}\\right) \\int_{2 \\pi} F p\\left(\\vec{\\omega}_{i}^{\\prime} \\cdot \\vec{\\omega}_{o}^{\\prime}\\right) \\int_{0}^{\\infty} e^{-\\sigma_{t c^{s}}} L_{i}\\left(x_{i}, \\vec{\\omega}_{i}\\right) d s d \\vec{\\omega}_{i} \\\\ &amp;=\\int_{A} \\int_{2 \\pi} S^{(1)}\\left(x_{i}, \\vec{\\omega}_{i} ; x_{o}, \\vec{\\omega}_{o}\\right) L_{i}\\left(x_{i}, \\vec{\\omega}_{i}\\right)\\left(\\vec{n} \\cdot \\vec{\\omega}_{i}\\right) d \\omega_{i} d A\\left(x_{i}\\right) \\end{aligned}\\] 论文认为单次散射的出射radiance \\(L_o\\)等于对折射路径\\(s\\)上的入射radiance进行积分（第一行的内部积分），再对入射的半球面立体角进行积分，总体上也就等价于固定了\\(x_o\\)，再对入射的立体角和单位入射面积进行二重积分，便可以得到\\(S^{(1)}\\)的隐式表达。 论文里还指出了diffusion term和single scattering有着不同的平均出射距离，并且两者的距离尺度有着很大的差别，对于有效消散系数\\(\\sigma_{tr}\\)远远小于消散系数\\(\\sigma_t\\)，single scattering随着\\(x_o\\)增加而衰减的情况会远明显于diffusion。 BRDF近似 完成上面两项的推导之后，论文提出了使用BRDF模拟BSSRDF的做法：假设surface上受到的光照是均匀的，这样就可以通过对于整个surface积分来实现计算（\\(r\\)从0积分到正无穷），对于single scattering也是同样的，就可以得到近似的BRDF： \\[ f_{r}\\left(x, \\vec{\\omega}_{i}, \\vec{\\omega}_{o}\\right)=f_{r}^{(1)}\\left(x, \\vec{\\omega}_{i}, \\vec{\\omega}_{o}\\right)+F \\frac{R_{d}}{\\pi}\\] 对于不透明，消散系数很大的材质（使得平均自由路径很短）来说，这个方法可以较好地模拟出BSSRDF（实际积分的权重多数集中于入射、反射点）。 BSSRDF实现 相较于BRDF，虽然我们已经简化了BSSRDF原本要求的入射区域A的积分而变成了在入射的位置进行多次采样，论文提出使用类似于分布式光线追踪的思路，在一个shadow ray的两端进行多次采样，并且针对single scattering和diffusion两项进行不同的采样。其中diffusion采样直接使用蒙特卡洛方法根据离出射点的距离，使用\\(\\sigma_{t r} e^{-\\sigma_{t r} d}\\)的权重进行采样。对于single scattering，由于入射和出射的折射光必须相交，论文对其进行了重组参数处理。 对于任意的几何表面，为了避免高度曲折情况导致的artifact，论文认为应该始终选择将双极子放置在最小距离\\(1/\\sigma'_t\\)处，这样可以处理在边界处出现的奇点问题。同时，如果物体表面有纹理材质，那么论文将纹理近似为仅仅覆盖在物体的表面，因此内部的体积光散射将不会收到纹理的variance造成的影响。","link":"/2022/04/09/PBR%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB%EF%BC%9AA-Practical-Model-for-Subsurface-Light-Transport/"},{"title":"PBR论文简读：Better BSSRDF Models(1)","text":"导语 在上一篇简读论文：PBR论文简读：A Practical Model for Subsurface Light Transport（后文将以Basic BSSRDF模型来指代本文提出的模型）提出BSSRDF模型后，人们陆陆续续发现了模型中的很多不足与需要改进的地方，因此接下来几篇blog将会简读几篇关于Basic BSSRDF模型的改进方法相关的论文。 Light Diffusion in Multi-Layered Translucent Materials, Donner'05 这篇论文主要指出了Basic BSSRDF中没有考虑到薄介质、多层、粗糙接触面的非理想情形下的问题，提出了多层（Multi-Layered）的BSSRDF模型。 薄介质散射 Basic BSSRDF中假设散射介质是半无限大的，但是对于介质厚度小到一定程度的时候（如，薄纸、树叶），显然这个假设是不成立的，同时光的出射部分能量就被忽视了，于是本文提出将光线能量划分为上表面的反射Reflectance \\(R(r)\\)和下表面的出射Transmittance \\(T(r)\\)两个部分，同时，偶极子需要应该满足分别在上下两个表面的的irradiance都为0： \\[\\int_{\\Omega+} L_{d}(r, \\vec{\\omega})(-\\vec{n} \\cdot \\vec{\\omega}) d \\vec{\\omega}=F_{d r} \\int_{\\Omega-} L_{d}(r, \\vec{\\omega})(\\vec{n} \\cdot \\vec{\\omega}) d \\vec{\\omega} \\quad \\text { at } z=0 \\tag{1}\\] \\[\\int_{\\Omega-} L_{d}(r, \\vec{\\omega})(\\vec{n} \\cdot \\vec{\\omega}) d \\vec{\\omega}=F_{d r} \\int_{\\Omega+} L_{d}(r, \\vec{\\omega})(-\\vec{n} \\cdot \\vec{\\omega}) d \\vec{\\omega} \\quad \\text { at } z=d\\] 其中第一个式子是Basic BSSRDF中满足的边界条件，第二个式子是本文提出下半边界应该满足的条件。同样的可以根据第二个式子推出： \\[\\phi(r)+2 A D \\frac{\\partial \\phi(r)}{\\partial z}=0 \\quad \\text { at } z=d\\] 但是有一个问题：偶极子模型使用的两个极子只能使得一侧的irradiance和为零，如果在另一侧加上一个负偶极子来保持下半侧的平衡，那么上半侧的平衡又会被破坏，因此只有在有无限个对称偶极子的情况下，irradiance和为0的条件才可能成立（如上图2）。以上半表面为0点，向下为正方向建立z轴，每一对偶极子交替关于\\(z = z_b\\)和\\(z = z_b+d\\)对称，可以得出每个正极子和负极子的z坐标表达式： \\[\\begin{aligned} &amp;z_{r, i}=2 i\\left(d+2 z_{b}\\right)+\\ell \\\\ &amp;z_{v, i}=2 i\\left(d+2 z_{b}\\right)-\\ell-2 z_{b}, i=-n, \\ldots, n, \\end{aligned}\\] 2n+1个极子对于Reflectance和Transmittance的贡献就是直接对其各自贡献的求和，其中Transmittance如下： \\[\\begin{array}{r} T(r)=\\sum_{i=-n}^{n} \\frac{\\alpha^{\\prime}\\left(d-z_{r, i}\\right)\\left(1+\\sigma_{t r} d_{r, i}\\right) e^{-\\sigma_{t r} d_{r, i}}}{4 \\pi d_{r, i}^{3}}- \\\\ \\frac{\\alpha^{\\prime}\\left(d-z_{v, i}\\right)\\left(1+\\sigma_{t r} d_{v, i}\\right) e^{-\\sigma_{t r} d_{v, i}}}{4 \\pi d_{v, i}^{3}} . \\end{array}\\] 同样的，上面的情况只讨论了薄板两边出射介质IOR相同的情况，实际情况下，两种介质的IOR往往是不同的（人类皮肤的表皮层的上侧为油脂，而下侧为真皮），这种情况下，体现在公式中不同的地方就在于菲涅尔反射项\\(A = \\frac{1 + F_{dr}}{1 - F_{dr}}\\)，同时也会导致极子坐标中的\\(z_b\\)项出现变化，解决方法也很简单，使用正确的上下表面\\(A\\)代入计算即可。 \\[\\begin{aligned} &amp;\\phi(r)-2 A(0) D \\frac{\\partial \\phi(r)}{\\partial z}=0, \\quad \\text { at } z=0 \\\\ &amp;\\phi(r)+2 A(d) D \\frac{\\partial \\phi(r)}{\\partial z}=0, \\quad \\text { at } z=d \\end{aligned}\\] \\[\\begin{aligned} z_{r, i} &amp;=2 i\\left(d+z_{b}(0)+z_{b}(d)\\right)+\\ell \\\\ z_{v, i} &amp;=2 i\\left(d+z_{b}(0)+z_{b}(d)\\right)-\\ell-2 z_{b}(0) \\end{aligned}\\] 多层材料的光扩散 接下来就可以通过上面的结论推导出多层材料的扩散效应了：将每层材料都看作一个薄板，以上一个薄板的出射作为下一层的入射来进行计算。论文里提出的具体方法是对入射通量\\(\\Phi\\)和Transmittance分布\\(T\\)在表面上做卷积： \\[M(r)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\Phi\\left(x^{\\prime}, y^{\\prime}, \\vec{\\omega}\\right) T\\left(r^{\\prime \\prime}\\right) d x^{\\prime} d y^{\\prime}=\\Phi(x, y, \\vec{\\omega}) * T(r)\\] 对于两层的材料，论文假设光在两种材料中的所有行为都是由于多重散射产生的，而这个假设在每个层都满足扩散理论的情况下都相当准确，于是对每一层的\\(M\\)计算就简化成了计算所有层的\\(T\\)，同样的，计算总体的Transmittance分布的方法依然是对两种材料的\\(T\\)做卷积： \\[T_{12}(r)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} T_{1}\\left(r^{\\prime}\\right) T_{2}\\left(r^{\\prime \\prime}\\right) d x^{\\prime} d y^{\\prime}=T_{1}(r) * T_{2}(r)\\] 但是这个公式代表着假设第一层传输到第二层材料的光只在第二层材料中传输，但是实际情况下光线于可能会在两种材料中来回弹射、散射，为了补偿这些行为，论文提出了如下的公式： \\[T_{12}=T_{1} * T_{2}+T_{1} * R_{2} * R_{1} * T_{2}+T_{1} * R_{2} * R_{1} * R_{2} * R_{1} * T_{2}+\\ldots\\] 但是如果直接用卷积硬算的话负担会很大，因此可以巧妙地利用傅立叶变换，将函数的卷积变成频域函数的乘积： \\[\\begin{aligned} \\mathcal{T}_{12} &amp;=\\mathcal{T}_{1} \\mathcal{T}_{2}+\\mathcal{T}_{1} \\mathcal{R}_{2} \\mathcal{R}_{1} \\mathcal{T}_{2}+\\mathcal{T}_{1} \\mathcal{R}_{2} \\mathcal{R}_{1} \\mathcal{R}_{2} \\mathcal{R}_{1} \\mathcal{T}_{2}+\\ldots \\\\ &amp;=\\mathcal{T}_{1} \\mathcal{T}_{2}\\left(1+\\mathcal{R}_{2} \\mathcal{R}_{1}+\\left(\\mathcal{R}_{2} \\mathcal{R}_{1}\\right)^{2}+\\left(\\mathcal{R}_{2} \\mathcal{R}_{1}\\right)^{3}+\\ldots\\right) \\end{aligned} \\tag{2}\\] 然后发现下面的式子其实是一个几何数列（等比数列），写出求和式，简化后有 \\[\\mathcal{J}_{12}=\\frac{\\mathcal{T}_{1} \\mathcal{J}_{2}}{1-\\mathcal{R}_{2} \\mathcal{R}_{1}}\\] \\[\\mathcal{R}_{12}=\\mathcal{R}_{1}+\\frac{\\mathcal{T}_{1} \\mathcal{R}_{2} \\mathcal{T}_{1}}{1-\\mathcal{R}_{2} \\mathcal{R}_{1}}\\] 这是双层的情况，多层的呢？很简单，只需要递归地把两层合并为一层的结果带入新的求解式即可！这样我们就可以求解任意层数的Transmittance和Reflectance系数了。 粗糙表面 前文提到过，Basic BSSRDF要求表面是平滑的，那非理想情况下的粗糙表面呢。观察原式(1)，我们需要做的是在计算表面irradiance为0的时候，不仅仅考虑由于菲涅尔系数导致的影响，而是应该将其视为一个完整的BRDF反射，比如论文中就引入了Cook-Torrance BRDF：\\(f_{r}\\left(x, \\vec{\\omega}_{o}, \\vec{\\omega}_{i}\\right)=\\frac{D\\left(x, \\vec{\\omega}_{o}, \\vec{\\omega}_{i}\\right) G\\left(x, \\vec{\\omega}_{o}, \\vec{\\omega}_{i}\\right) F\\left(x, \\vec{\\omega}_{i}, \\vec{\\omega}_{o}\\right)}{4\\left(\\vec{\\omega}_{i} \\cdot \\vec{n}\\right)\\left(\\vec{\\omega}_{o} \\cdot \\vec{n}\\right)}\\)，然后计算新的\\(\\rho_d\\)替换\\(F_{dr}\\)（这里就无法使用解析式来近似了，论文里使用了预计算蒙特卡洛采样来得到数值解），同样的，\\(A\\)项也需要因此重新计算：\\(A=\\frac{1+\\rho_{d}}{1-\\rho_{d}}\\)，最后把漫射传播方程中的菲涅尔传输系数更改为BRDF传输系数（论文假定了光线仅进行传输和反射两种行为，并且使用了一个参数为\\(\\omega_o\\)的预计算表来插值计算\\(\\rho_{dt}\\)）： \\[\\rho_{d t}\\left(x, \\vec{\\omega}_{o}\\right)=1.0-\\int_{2 \\pi} f_{r}\\left(x, \\vec{\\omega}_{o}, \\vec{\\omega}_{i}\\right)\\left(\\vec{\\omega}_{i} \\cdot \\vec{n}\\right) d \\vec{\\omega}_{i}\\] 论文还提出了虽然对于简单几何，直接使用Reflectance的分布就可以搞定，但是对于复杂并且很薄的几何，应该使用\\(R\\)和\\(T\\)复合的分布计算（即对于着色点和光线入射点的法线进行点乘，如果两者同向说明反射的占比居多，两者偏离越多说明透射占比越多）： \\[P_{d}(r)=\\frac{1}{2}\\left(\\vec{n}_{s} \\cdot \\vec{n}_{l}+1\\right) R_{d}(r)+\\frac{1}{2}\\left(1-\\vec{n}_{s} \\cdot \\vec{n}_{l}\\right) T_{d}(r)\\] 最后论文还描述了关于多层texture的做法，对于一张根据观测所得的贴图： 使用反射分布对纹理进行卷积（根据光在材质中的漫射对纹理进行模糊） 将纹理归一化（注：这里的归一化是指用这个像素的颜色去除以贴图所有像素的平均值），排除表面自带的BSSRDF影响 最后，在渲染的时候通过归一化的纹理值来放缩辐射发射率 A Quantized-Diffusion Model for Rendering Translucent Materials, d'Eon'11 前言 这篇文章的方法和物理相关性有点高，而且内容对于我一个cs学生来说有点抽象……花了很长时间才看完，如果总结的有什么不对的地方，希望读者不吝赐教。 这篇论文指出了Basic BSSRDF模型在经典散射理论(Classic Diffusion Theory)下对于高吸收率材料、近照明点模拟不足的缺陷，以及多偶极子理论在超薄材料层、高频照明情况下缺陷。提出了全新的量化漫射理论，同时为高斯和BSSRDF提供了可变精度的构造方法。 问题与改进方法 根据传统的方法，我们会使用球面谐波函数来对传播方程进行截断展开（前几篇论文中一般选择将其阶段至N=1，一开始我并不理解这个展开，通过和研究生学长的讨论大概明白了，由于辐射传播方程需要通过球面所有方向到该位置的积分来得到irradiance的值，通过低阶的SH展开，去掉高频信息保留低频信息，看作辐射在体积内各向同性传递），然后选择各向同性的张量通量来产生经典漫射系数（个人不太懂这段叙述），这两步看起来确实有点过于“随意”了，因此许多重要的改进方法都是基于这两个步骤提出的。 对于经典漫射结果在高吸收率和近距离光源不准的情况下，论文引用了一个更好的Grosjean近似，这是一个fluence的近似解析解： \\[ \\phi(r)=\\frac{\\mathrm{e}^{-\\mu_{t}^{\\prime} r}}{4 \\pi r^{2}}+\\frac{1}{4 \\pi} \\frac{3 \\mu_{s}^{\\prime} \\mu_{t}^{\\prime}}{2 \\mu_{a}+\\mu_{s}^{\\prime}} \\frac{\\mathrm{e}^{-\\sqrt{\\frac{\\mu_{a}}{D} r}}}{r} \\tag{1} \\] 其中 \\[ D=\\frac{2 \\mu_{a}+\\mu_{s}^{\\prime}}{3\\left(\\mu_{a}+\\mu_{s}^{\\prime}\\right)^{2}} \\] 满足新的散射方程： \\[-D \\nabla^{2} \\phi(\\vec{x})+\\mu_{a} \\phi(\\vec{x})=\\alpha^{\\prime} Q(\\vec{x})\\] 同时这个近似还更好地分开了single scattering和multiple scattering，降低了经典漫射模型中的误差。相较于真正的解 \\(\\phi(r)=\\frac{\\mathrm{e}^{-\\mu_{t} r}}{4 \\pi r^{2}}+\\frac{\\mu_{s}}{2 \\pi^{2} r} \\int_{0}^{\\infty} \\frac{\\arctan ^{2} u}{u-\\alpha \\arctan u} \\sin \\left(r \\mu_{t} u\\right) d u\\)，Grosjean近似有相近的形式和相同的零阶矩，满足： \\[\\int_{0}^{\\infty} 4 \\pi r^{2} \\phi(r) d r=\\frac{1}{\\mu_{a}}\\] 边界条件 之前提到过的\\(z_b = 2AD\\)，使用新的\\(A(\\eta)=\\frac{1+3 C_{2}}{1-2 C_{1}}\\)，其中 \\[C_{i}=\\int_{0}^{\\pi / 2} F_{r}(\\eta, \\theta) \\cos ^{i}(\\theta) \\sin (\\theta) d \\theta\\] 然后论文给出了\\(C_1\\)和\\(C_2\\)诡异的多项式近似，这里就不贴出来了。 前两篇论文提出使用偶极子/多极子的方法来求解边界条件，但是对于过于薄的材料，这两种方法都会受到限制：第一个正极子会被放置在薄板的下方： 同时，由于可能的表面细节或者阴影造成的高频光线会因为偶极子的方法被强制地各向同性散射，这样会导致返回表面的散射光被过度模糊化、失去高频信息。 拓展源 漫射模型 论文中引用了探照灯问题的一个解法：拓展源函数，即在深度为\\(z&gt;0\\)的所有位置放置一个强度为\\(Q(z)\\)的各向同性点光源： \\[Q(z)=\\alpha^{\\prime} \\mu_{t}^{\\prime} \\mathrm{e}^{-\\mu_{t}^{\\prime} z}\\] 对于一个给予的格林函数\\(\\Phi(r)\\)，需要对如下的积分求解： \\[\\int_{0}^{\\infty} \\Phi\\left(\\sqrt{r^{2}+z^{2}}\\right) Q(z) d z=\\int_{0}^{\\infty} \\Phi\\left(\\sqrt{r^{2}+z^{2}}\\right) \\alpha^{\\prime} \\mu_{t}^{\\prime} \\mathrm{e}^{-\\mu_{t}^{\\prime} z} d z\\] 论文接下来就提出了一个十分巧妙的假设：把格林函数当作一个三维归一化的高斯函数，这样就可以把积分转化为二维高斯函数： \\[\\int_{0}^{\\infty} G_{3 \\mathrm{D}}\\left(v, \\sqrt{r^{2}+z^{2}}\\right) Q(z) d z=\\frac{1}{2} \\mu_{s}^{\\prime} f\\left(\\mu_{t}^{\\prime 2} v / 2\\right) G_{2 \\mathrm{D}}(v, r)\\] 其中\\(f(x)=\\mathrm{e}^{x} \\operatorname{erfc}(\\sqrt{x})\\)，这样一来得到了解析解，就可以避免昂贵的数值积分。 量化漫射 根据爱因斯坦提出的理论，离开点光源的粒子或者光子呈现高斯分布，其平均位移和\\(\\sqrt{tD}\\)成正比。稳态格林函数的解也就是过去时间内发射的所有贡献： \\[\\frac{1}{4 \\pi D} \\frac{\\mathrm{e}^{-r \\sqrt{\\frac{\\mu_{a}}{D}}}}{r}=\\int_{0}^{\\infty} \\frac{c}{(4 \\pi D c t)^{3 / 2}} \\mathrm{e}^{-\\mu_{a} c t} \\mathrm{e}^{-r^{2} /(4 D c t)} d t\\\\ = \\int_{0}^{\\infty} \\mathrm{e}^{-\\tau \\mu_{a}} G_{3 \\mathrm{D}}(2 D \\tau, r) d \\tau \\] 这也意味着在某个时间\\(\\tau\\)，发射的光子的分布是呈现以\\(2D\\tau\\)的三维高斯分布的。接下来，我们将时间间隔量化，分割为\\(k+1\\)个时间片\\(\\tau_i\\)，接下来使用一个带权重的三位高斯分布来近似光子在对应时间片\\([\\tau_i, \\tau_{i+1}]\\)的分布吗，这样就可以把上面的积分转化为求和（有点高斯-勒让德积分的味道）： \\[\\phi(r)=\\int_{0}^{\\infty} \\mathrm{e}^{-\\tau \\mu_{a}} G_{3 \\mathrm{D}}(2 D \\tau, r) d \\tau \\approx \\sum_{i=0}^{k-1} w_{i} G_{3 \\mathrm{D}}\\left(v_{i}, r\\right)\\] 简单的，权重就是我们去掉的指数项在时间片的积分，可以很轻易地使用解析方法求得。通过上述方法求出的展开式和正确的漫射解有着相同的零阶矩。时间片的选择论文直接给出了一个常数\\(\\tau_i = s^{i - 1}\\tau_1, s\\in [1.5, 2.0]\\)，结果还是令人十分满意的，论文中给出的例子随着\\(r\\)的变化，误差仅有0.002%（具体数据请参见论文）。 拓展多极子模型 接下来将多极子模型和量化漫射模型结合起来，前文提到的公式(1)中的弹道项（不知道这么翻译对不对，原文是ballistic term）产生了单散射光被单独考虑；其余项则使用量化漫射的有限高斯展开处理。对于有限层数的偏移为\\(m\\)的高斯源，在\\(z_1\\)和\\(z_2\\)的积分使用如下展开方法： \\[\\begin{array}{c} \\int_{z_{1}}^{z_{2}} Q(z) G_{3 \\mathrm{D}}\\left(v, \\sqrt{r^{2}+(z+m)^{2}}\\right) d z=G_{2 \\mathrm{D}}(v, r) w_{\\phi}\\left(v, z_{1}, z_{2}, m\\right), \\\\ w_{\\phi}\\left(v, z_{1}, z_{2}, m\\right)=\\int_{z_{1}}^{z_{2}} \\frac{\\mathrm{e}^{-\\frac{(-z+m)^{2}}{2 v}}}{\\sqrt{2 \\pi v}} \\alpha^{\\prime} \\mu_{t} \\mathrm{e}^{-\\mu_{t} z} d z= \\\\ \\frac{\\alpha^{\\prime} \\mu_{t}}{2} \\mathrm{e}^{m \\mu_{t}+\\frac{\\mu_{t} v}{2}}\\left(\\operatorname{erf}\\left[\\frac{m+\\mu_{t} v+z_{2}}{\\sqrt{2 v}}\\right]-\\operatorname{erf}\\left[\\frac{m+\\mu_{t} v+z_{1}}{\\sqrt{2 v}}\\right]\\right) . \\end{array}\\] Updated 2022/7/22：在实现的时候，发现这个模型在\\(r\\)极大时根本没有办法拟合MC的结果，经过长时间的排查问题出现在：\\(w_\\phi\\)的公式在\\(v\\)过大的时候是极其不稳定的，找遍全网终于找到了可能是d'Eon在实现的时候使用的\\(v\\)较大时的稳定函数： $ 𝑤_=(′ _𝑡 𝑣 𝑒{𝑐_1−𝑐_22/2𝑣} (3𝑣2−𝑣𝑐_22+𝑐_2^4 ))/( 𝑐_2^5 )$，其中 \\(𝑐_1=\\mu_𝑡 (𝑚+(\\mu_𝑡 𝑣)/2),𝑐_2=𝑚+\\mu_𝑡 𝑣\\) ，这里我在实现的时候就选择在指数\\(c_1 &gt; 20\\)时切换到这个公式，很好地解决了函数地拟合问题。 表面通量是一个高斯分布，其权重\\(w_{\\vec{E}}\\)计算如下吐槽一下这篇文章里公式真的好多： \\[\\begin{aligned} w_{\\vec{E}}\\left(v, z_{1}, z_{2}, m\\right) &amp;=D \\mu_{t}\\left[-w_{\\phi}\\left(v, z_{1}, z_{2}, m\\right)\\right.\\\\ &amp;\\left.+\\frac{\\alpha^{\\prime}\\left(\\mathrm{e}^{-\\frac{m^{2}}{2 v}-\\frac{\\left(m+\\mu_{v} v\\right) z_{1}}{v}-\\frac{z_{1}^{2}}{2 v}}-\\mathrm{e}^{\\left.-\\frac{m^{2}}{2 v}-\\frac{\\left(m+\\mu_{t} v\\right) z_{2}}{v}-\\frac{z_{2}^{2}}{2 v}\\right)}\\right]}{\\sqrt{2 \\pi v}}\\right] \\end{aligned}\\] 对于多极子的每一对编号为\\(j\\)的源，偶极子反射率fluence权重和flux权重计算如下： \\[\\begin{array}{l} w_{\\phi R}(v, j)=w_{\\phi}\\left(v, 0, d, m_{r, j}\\right)-w_{\\phi}\\left(v, 0, d,-m_{v, j}\\right) \\\\ w_{\\vec{E} R}(v, j)=w_{\\vec{E}}\\left(v, 0, d, m_{r, j}\\right)+w_{\\vec{E}}\\left(v, 0, d,-m_{v, j}\\right) \\end{array}\\] 将每一对偶极子反射率和进行带权求和总反射率权重，这里引用了论文在开始的时候提到的KP出射计算法（即使用拓展源计算所有出射的能量，结果是fluence和flux在表面上的线性组合：\\(R(r)=C_{\\phi} \\phi(r, z=0)+C_{\\vec{E}}(-D \\nabla \\phi(r, z=0) \\cdot(0,0,-1))\\)，$C_{}=(1-2 C_{1}) \\(，\\) C_{}=(1-3 C_{2})$）对表面上的两项进行加权求和： \\[w_{R}(i)=\\sum_{j=-n}^{n}\\left[C_{\\phi}\\left(\\eta_{\\text {top }}\\right) w_{\\phi R}\\left(v_{i}, j\\right)+C_{\\vec{E}}\\left(\\eta_{\\text {top }}\\right) w_{\\vec{E} R}\\left(v_{i}, j\\right)\\right]\\] 然后我们再用格林函数展开对所有的高斯函数进行加权求和： \\[R^{+}(r)=\\alpha^{\\prime} \\sum_{i=0}^{k-1} w_{R}(i) w_{i} G_{2 \\mathrm{D}}\\left(v_{i}, r\\right)\\] 即可得到拓展多极子模型下的向下反射率分布，同样的方法，把位置挪到\\(d\\)，就可以得到向下传输分布\\(T^+(r)\\) 多层材料 回顾一下，在Donner'05那篇论文里，对于多层材料采用了傅立叶变换+递归回代\\(\\mathcal{T}\\)和\\(\\mathcal{R}\\)的方法，而d'Eon'11这篇论文在附录中提出了对分布的高斯函数进行快速卷积的函数 去掉了快速傅立叶变换并且保证了能量守恒。 使用QD BSSRDF进行渲染 对于BSSRDF的S项，论文多提出了一个减弱强度的传输项\\(S^{(0)}\\)，使用与深度\\(d\\)相关的\\(e^{-d\\mu_t}\\)来计算，然后单次散射项直接使用Jensen'01的方法计算，多散射项则使用本文提到的量化漫射计算。 A Better Dipole, d'Eon'12 这篇论文主要讲述在偶极子模型(Jensen'01)下通过改进参数（大部分来自d'Eon'11提出的量化模型）来实现复杂度几乎不改变的情况下提升模型的准确率的方法（前排提示，这篇论文的内容很简单易懂，除去各种diagram只有3页内容）。 Previous Work 首先可以回顾一下以往提出的几种模型其各自的优缺点： Jensen'01：提出了基本的BSSRDF概念以及一个实际可用的模型以及用偶极子计算Diffusion Approximation，缺点就不说了，假设了不少理想状况 Donner'05：提出了多极子模型来补偿有限深度介质的\\(T\\)透射率，考虑了透射传输以支持多层材料的情况，同时将计算\\(R\\)项时使用的菲涅尔项替换成BRDF以支持粗糙面；缺点是对于超薄板、高频光（overblur&amp;high-frequence loss）、高吸收率、近源（\\(r\\)很小的时候）准确率不足（d'Eon'11） d'Eon'11：提出了全新的量化漫射模型，通过新的拓展源函数来计算fluence，同样使用于多极子模型，利用时域上光子呈高斯分布的原理，使用时域上的积分确保了多极子模型在任何情况下的物理正确性，并且正确地解耦合了diffusion和single scattering；缺点是一方面和前几种理论基于不同的原理，理解和重构起来较为麻烦，另一方面尽管相较于前几种Model已经有了很大的改进，但是对于各向异性材料的支持仍然不是很好，同时论文最后也提到对于多层材料的情况，受限于Donner'05的模型，将每次进入下一层的illumination都看作是一个漫射面光源，没有做论文中提到的single scattering的支持。 在这个改进的双极子模型中，同样沿用了量化漫射模型，但是去掉了拓展源项\\(Q(z) = \\alpha'\\mu_t'e^{-\\mu_t'z}\\)，目的是将d'Eon'11模型中扩散渐进和菲涅尔一致的边界条件得到更广泛的使用。最终的模型仍然使用了偶极子的模型，避免了复杂的量化漫射格林函数积分转化为高斯和的计算，并且很容易将已有的Jensen'01的模型改造过来。虽然准确率有所增加，但是仍然会具有偶极子模型的众多不足之处，因此属于在特定情况下的改进方法。 Methods 首先对比Jensen'01，将BSSRDF的表达式改造成了： \\[S_{d}\\left(x_{i}, \\vec{\\omega}_{i} ; x_{o}, \\vec{\\omega}_{o}\\right)=\\frac{1}{\\pi} F_{t}\\left(x_{i}, \\vec{\\omega}_{i}\\right) R\\left(\\left\\|x_{i}-x_{o}\\right\\|_{2}\\right) \\frac{F_{t}\\left(x_{o}, \\vec{\\omega}_{o}\\right)}{1-2 C_{1}\\left(\\frac{1}{\\eta}\\right)}\\] 就是在出射菲涅尔项的下面增加了一个归一化系数作为分母（d'Eon'11），对于\\(C_1\\)给出的近似如下： \\[2 C_{1} \\approx\\left\\{\\begin{array}{cc} 0.919317-3.4793 \\eta+6.75335 \\eta^{2}-7.80989 \\eta^{3} &amp; \\\\ +4.98554 \\eta^{4}-1.36881 \\eta^{5}, &amp; \\eta&lt;1 \\\\ -9.23372+22.2272 \\eta-20.9292 \\eta^{2}+10.2291 \\eta^{3} &amp; \\\\ -2.54396 \\eta^{4}+0.254913 \\eta^{5}, &amp; \\eta&gt;=1 \\end{array}\\right.\\] 传统的理论尝试在diffusion term中并入对single scattering的计算，论文指出这是很不科学的并且在某些情况下会导致较为严重的误差，因此single scattering在本文模型中会被单独的计算。 接下来，就是改进点了，其实Better Dipole的主要思想也就是通过结合d'Eon'11的参数和Dipole模型来进行计算，参数修正表如下： 这篇论文后面的内容基本就是几种不同模型在不同参数情况下的对比了（方便我们在不同的情况下使用不同的模型进行渲染），这里就不再赘述，如果以后看到比较感兴趣的可能会挑出来讲一讲。","link":"/2022/04/12/PBR%E8%AE%BA%E6%96%87%E7%AE%80%E8%AF%BB%EF%BC%9ABetter-BSSRDF-Models(1)/"},{"title":"PBR读书笔记一：Geometry &amp; Transformation","text":"这会是一个持续更新的系列，用来记录我在阅读《Physically Based Rendering》的一些读书心得和brief。 四元数 Quaternions 之前玩Unity的时候就有过使用四元数的经历，当时还不太明白万向锁和四元数的本质，看了这一章之后遍会有更加深入的体会。 四元数发明的初衷是对于复数的拓展，\\(q=(x,y,z,w)=w+x\\vec i+y\\vec j+z\\vec k\\)，ijk四个量的乘法运算是非交换的。与此同时，\\(q=(q_{xyz}, w)\\)，因此对两个四元数做点乘，两个分量： \\[(q\\cdot q')_{xyz} = q_{xyz}\\times q'_{xyz} + q_wq'_{xyz} + q'_wq_{xyz}\\] \\[(q\\cdot q')_{w} = q_w\\cdot q'_w - (q_{xyz}\\cdot q'_{xyz})\\] 定义单位四元数\\(x^2+y^2+z^2+w^2=1\\)，同时很重要的，在三维空间中，点\\(p\\)绕着一个单位轴\\(\\vec v\\)进行\\(2\\theta\\)的旋转，可以通过四元数\\(q = (\\vec v\\sin\\theta, \\cos\\theta)\\)实现： \\[p' = qpq^{-1}\\] 其中对于四元数\\(q=(\\vec v, w)\\)，求其共轭四元数：\\(Q^*=(-\\vec v, w)\\)，而对应的其逆\\(q^{-1}=\\frac{Q^*}{|q|}\\) 接下来还有四元数插值的部分，但是主要目的不在这里，就先略过了（animation相关）。 看了一圈，这一章比较陌生的知识差不多结束了。","link":"/2021/12/24/PBR%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9AGeometry-Transformation/"},{"title":"PBR读书笔记三：Color &amp; Radiometry","text":"众所周知，自然、物理界的光照不是靠RGB三个离散分量描述的，而是由不同强度的不同波长\\(\\lambda\\)的光组成的，因此如果要基于物理地渲染，对于自然光谱的模拟是必不可少的，在pbrt和mistuba两款渲染器中，都采用了Spectrum类来承载光谱数据，对于不同波长的数据，我们描述为SPD，aka spectral power distribution，光谱能量分布。 Spectrum 自然界光谱不是离散描述的，于是我们可以像傅立叶变换一样，用一组带系数的基底函数\\(c_iB_i(\\lambda)\\)来逼近实际的波形。 pbrt中，定义了两种实际的Spectrum类，并且使用一个typedef来在实际的使用中切换两者的类型： 12typedef RGBSpectrum Spectrum;// typedef SampledSpectrum Spectrum; mitsuba中也用了相同的操作来切换单精度和双精度的浮点数。 小插曲 c++里可以使用typedef来定义新类型，特别是在c里面，为了避免struct关键字冗余，往往会使用其定义结构体，那么c++推出的using关键字与其相有什么区别呢？ ——答案是，没有，在标准中被如此描述： A typedef-name can also be introduced by an alias-declaration. The identifier following the using keyword becomes a typedef-name and the optional attribute-specifier-seq following the identifier appertains to that typedef-name. It has the same semantics as if it were introduced by the typedef specifier. In particular, it does not define a new type and it shall not appear in the type-id. 在c++中，我们可以放心大胆地使用using替换define等一系列关键字！同时，我也比较推荐常量使用constexpr定义，而不是使用#define，让我们享受类型系统带来的便利。 定义了一个基类 123456template &lt;int nSpectrumSamples&gt; class CoefficientSpectrum{public: // public functionsprotected: Float c[nSpectrumSamples];} 这里，pbrt假定我们使用了系数线性地放缩基函数并且求和。 SampledSpectrum 正如其名，SampledSpectrum对光谱的一个区间进行采样，并且等宽地对波长进行系数记录。 XYZ色彩 人类视觉的一个重要属性在于：任何颜色都可以通过三个颜色分量表示，这使得对于任意的SPD，我们都可以构建一套三维分量\\(x_\\lambda\\)，\\(y_\\lambda\\)，\\(z_\\lambda\\)。 使用XYC分量构建的SPD 分量的计算如下： \\[x_\\lambda = \\int_\\lambda S(\\lambda)X(\\lambda)\\text{d}x\\] 在SampledSpectrum中则是对离散的分量求和： \\[x_\\lambda \\approx \\frac{\\lambda_{\\text{end}} - \\lambda_{\\text{start}}}{N}\\sum^{N-1}_{i=0}{X_ic_i}\\] 这样我们就可以得到SampleSpectrum到RGBSpectrum的转换。 RGBSpectrum 其实RGB说白了也是三个特殊的XYZ分量，其在LCD和LED上的波长分布还有所不同： LCD的RGB波长分布 LED的RGB波长分布 我们可以通过上述的公式将任意的XYZ色彩SampledSpectrum转化为RGB色彩空间中的色彩RGBSpectrum；但是反过来，一个RGB色彩可能对应于无数个XYZ色彩，于是pbrt遵循如下转换规则： 如果所有的RGB系数相同，则结果SPD为常量。 我们希望计算得到的SPD色彩的函数图像尽量的平滑。 这里pbrt参考了An RGB-to-spectrum conversion for reflectances这篇论文来实现。 Radiometry 略（因为已经通过CMU 15-462学过了）","link":"/2022/01/05/PBR%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9AColor-Radiometry/"},{"title":"PBR读书笔记二：Basic Shapes","text":"在整个图形学领域，空间中的物体都是由基本的Shape构成的，比如基本的几何形体：Sphere、Box；或者能够达成更加复杂表现的Mesh等。这一章主要讲述了几种不同的形体的定义和相关计算。 形体基类 PBRT使用Shape类来为所有形体创建了一个基类，reverseOrientation用来决定图形的法线是否翻转（用来确定图形的内、外）。 对于每个形体有如下的基础函数和解释： 12virtual Bounds3f ObjectBound() const = 0;virtual Bounds3f WorldBound() const; aabb bounding box，用于加速相交求解。 12345678virtual bool Intersect(const Ray &amp;ray, Float *tHit, SurfaceInteraction *isect, bool testAlphaTexture = true) const = 0;virtual bool IntersectP(const Ray &amp;ray, bool testAlphaTexture = true) const { Float tHit = ray.tMax; SurfaceInteraction isect; return Intersect(ray, &amp;tHit, &amp;isect, testAlphaTexture);} 光线和物体的相交（实际），保证： - 光线未达到终点 - 返回的相交点最近 intersectP方法用于忽略一些返回值。 1virtual Float Area() const = 0; 物体的面积，用于计算面积光源。 由于物体不保证封闭，并且光线追踪算法的特殊性，pbrt没有采用背面剔除算法。 123456789virtual Interaction Sample(const Point2f &amp;u) const = 0;virtual Float Pdf(const Interaction &amp;) const { return 1 / Area();}virtual Interaction Sample(const Interaction &amp;ref, const Point2f &amp;u) const { return Sample(u);}virtual Float Pdf(const Interaction &amp;ref, const Vector3f &amp;wi) const; 剩下的就是和光照有关的重要性采样(Sample)、概率分布函数(pdf)的内容，不作为重点赘述。 光线与包围盒的相交 对于一个定义\\(\\vec r = o + t\\vec d\\)的光线，假设其与平面\\(ax+by+cz+d = 0\\)相交，可有解为\\(t = \\frac{-\\vec d-((a,b,c)\\cdot o)}{((a,b,c)\\cdot \\vec d)}\\)，而对于由\\(x\\)决定的平面，则可以进一步地简写为：\\(t_0=\\frac{x_0-o_x}{d_x}\\)。 则相应地，我们的代码如下： 123Float invRayDir = 1 / ray.d[i];Float tNear = (pMin[i] - ray.o[i]) * invRayDir;Float tFar = (pMax[i] - ray.o[i]) * invRayDir; 自然，这两个Near和Far的变量的顺序并不一定正确，于是需要根据两个变量的大小交换，这里需要考虑到浮点数出现0/0导致的NaN问题，这里利用一条性质： NaN浮点数和任何其他浮点数进行比较的返回必定是false 于是更新t0和t1的代码需要仔细一些额外处理（t0、t1是最终返回的值）： 12t0 = tNear &gt; t0 ? tNear : t0;t1 = tFar &lt; t1 ? tFar : t1; （虽然我觉得用stl的std::max和std::min会好一些","link":"/2021/12/30/PBR%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9ABasic-Shapes/"},{"title":"PBR读书笔记四：Sampling Theory","text":"对图像的描绘，本质上是场景重建(reconstruction)与信号处理(signal processing)，简单来说就是用离散的采样（像素点）来对连续的真实世界进行重建，那么就涉及到采样(sampling)的问题了。 傅立叶分析 傅立叶分析可以用来评估重建函数的质量，同时其被用来在频域上分析不同频率的函数，通常来说，高频率的函数变换的较为频繁、较快；低频率的函数变化的较缓慢。如下是两个函数图像： 与之对应的，是其在频域上的函数图像： 即运用傅立叶变换： \\[F(\\omega)=\\int^\\infty_{-\\infty}f(x)\\exp{(-\\text{i}2\\pi \\omega x)}\\text{d}x\\] 傅立叶变换具有对称性，即函数对应的频域函数，对这个频域函数再做一次傅立叶分析得到的函数是原函数。同时，傅立叶变换中还有一个重要特性，两个函数的点积结果进行傅立叶变换得到的函数等于两个函数进行傅立叶变换之后的卷积： \\[\\text{F}\\{f(x)g(x)\\} = F(\\omega)\\circledast G(\\omega)\\] 反走样 走样分为两种：采样瑕疵造成的前走样和重建造成的后走样。 非均匀采样 众所周知的，在GAMES202的阴影作业里提供了两种采样方法： - uniform disk sampling - poisson disk sampling 具体理论可以参考wiki-非均匀采样。在pbrt中认为虽然非均匀采样和均匀采样均无法完好地复原信号，但是非均匀的采样可以将规律性的走样转化为噪声，而对于人类的视觉系统，噪声比走样更容易被忽略。 自适应采样 理论上来说，频率越高的地方需要的采样率越高，于是可以通过增大那些发生剧变的区域采样率来达到自适应的采样。 预滤波 顾名思义，在采样之前对原始信号进行滤波，这样防止出现无法被良好采样的超高频信号。比较常用的方法就是通过一个卷积，如： \\[f(x)\\circledast \\text{sinc}(2\\omega_s x)\\] 使用了一个sinc的滤波器，消除难以采样的高频信息： sinc滤波器 图像重建 采样的结果最后是用来进行图像的重建的，这里就会遇到之前提到的后走样问题，一个典型的box filter的结果如下图 使用箱型过滤器的结果 可以选择的滤波器有很多，pbr中定义了滤波器的基础属性radius，如下图： 滤波器参数 radius是所有滤波器共有的属性，所有的滤波器也都继承自基类： 123456789class Filter {public: virtual ~Filter(); Filter(const Vector2f &amp;radius) : radius(radius), invRadius(Vector2f(1 / radius.x, 1 / radius.y)) { } virtual Float Evaluate(const Point2f &amp;p) const = 0; const Vector2f radius, invRadius;}; Box Filter 箱型滤波器是最为简单的一种滤波器，但是问题也很明显：高频率样本会发生泄漏的现象，这就是后走样形成的重要原因。这种泄漏的现象不仅仅会发生在采样率低于奈奎斯特极限的时候，在函数频率接近甚至超过奈奎斯特极限的时候同样会发生。 Triangle Filter 性质与箱型过滤器类似，略 Gaussian Filter pbrt中对其评价为： The Gaussian does tend to cause slight blurring of the final image compared to some of the other filters, but this blurring can actually help mask any remaining aliasing in the image. 也就是说高斯滤波器可以为图像带来有益的模糊以掩饰走样。一维高斯滤波器函数为： \\[f(x) = \\exp{(-\\alpha x^2)} - \\exp{(-\\alpha r^2)}\\] 其中第二项的目的是为了保证高斯函数最后能落至0，而不是一个陡峭的剧变。二维的高斯函数则是简单的两个一维高斯函数的乘积。 Mitchell Filter 暂略","link":"/2022/01/11/PBR%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9ASampling-Theory/"},{"title":"Siggraph Asia 2024渲染论文速递","text":"image.png InfNeRF: Towards Infinite Scale NeRF Rendering with O(log n) Space Complexity 用八叉树给 NeRF +NGP 叠上了八叉树，每个八叉树节点再用 2048 的 NGP Nerf，不懂 NeRF，但是看起来像 A+B 的工作 GS^3: Efficient Relighting with Triple Gaussian Splatting 吴鸿智老师组的工作，给 3d gaussian 引入了更复杂的参数，把着色拆分成 Lambertian+angular gaussian（又进一步 PBR 化了），再把单光源的阴影拆出来。看起来能处理的材质复杂度就高了很多，毛发什么的表现也不错，可惜似乎只支持单光源。 代码开源在 https://github.com/gsrelight/gs-relight image.png MARS: Multi-sample Allocation through Russian roulette and Splitting Adaptive multi-sample MIS，在之前的方法（只优化 variance）上额外考虑 sample 的 cost（实际上最后是优化一个分段的 proxy），基于不动点迭代来分配每个 vertex 的 MIS 样本数，这样可以一定程度上提升时间效率。但是实际结果提升有限，RRS 真是要被卷烂了。 image.png Efficient Neural Path Guiding with 4D Modeling image.png Dynamic Neural Radiosity with Multi-grid Decomposition 都是北大李胜老师组的工作，思路很像就一起了，都是用 Sparse Grid 来做高维输入（前者加了一个 t，后者加了一些可编辑的参数），使得大伙能做动态场景了。但是后者看起来本质上是在 Neural radiosity 上提出一些编码整的活（频率编码、SH 编码方向），速度还是受限于场景的可变参数，PG 不是很懂不予置评。NGP 真是无敌啊，把整个神经渲染编码盘起来了。 image.png Neural Global Illumination via Superposed Deformable Feature Fields 浙大霍宇驰老师组的神经渲染工作，在 NeLT 的基础上加上了可变形的 NGP +triplane 编码来实现更好的空间特征映射，并且用多个物体并行编码的方式把 encode 的速度提上去了，效果还是很 fancy 的。可惜的是最后还是接的一个大 decoder，而且并行化编码比较玄学，GPU 要是吃满了也只能老老实实串行了，场景能动的物体一多帧率也还是会往下掉不少。 image.png End-to-End Hybrid Refractive-Diffractive Lens Design with Differentiable Ray-Wave Model 折射-衍射的 ray-wave 模型可微化，使得透镜的优化可以端到端化，很有意思的基石性工作。不过看起来对比先前工作提升的主要是精确性，希望有朝一日这样的工作能拯救我没对上焦的照片（x） image.png A Statistical Approach to Monte Carlo Denoising 这个年代能看到 neural-free 的 denoiser 确实不容易啊，核心是提出了一种基于 Welch t-test 的采样策略，用来接收/拒绝临近像素样本做 denoise。但是缺点也很明显，统计方法是需要优秀样本来辅助的，在低 spp 的情况下还是打不过一众 neural denoiser，而且似乎这个方法是需要输入像素所有 MC 样本的，导致实用性进一步下降。 image.png Hierarchical Light Sampling with Accurate Spherical Gaussian Lighting AMD 关于 manylight 的工作，在 stochastic lightcut 的基础上把树的节点用 SG 表示来得到更紧凑的表达，用 NDF 过滤来保证 MC 采样的无偏性。可以和 ReSTIR 结合起来用生成更好的样本，看了下 Reddit 上有人实现的给了好评，不过树还是得在 CPU 上建，Lightcuts 这一类方法感觉还是不太 GPU 友好。 image.png A Dynamic By-example BTF Synthesis Scheme 闫令琪老师组的工作，熟悉的材料啊。把 BTF 的 6D 分解成两张 2D 方向纹理，再把 position 作为一个编码参数总共三张（原文里称为 triple plane），在运行时用 MLP 动态合成 BTF，但是似乎 MLP 还是 per material per train 的，让人不禁想问引入这三张纹理的意义（不懂，求指正）。 image.png Dance-to-Music Generation with Encoder-based Textual Inversion 不是渲染，但是看起来很有意思，从跳的舞蹈里提取 text prompt 来指导音乐合成，开源在 lsfhuihuiff/Dance-to-music_Siggraph_Asia_2024: The official code for “Dance-to-Music Generation with Encoder-based Textual Inversion“。似乎用的是固定 prompt a @ music with * as the rhythm，那大概考虑不到舞蹈过程中的节奏变换:-(","link":"/2024/12/26/Siggraph-Asia-2024%E6%B8%B2%E6%9F%93%E8%AE%BA%E6%96%87%E9%80%9F%E9%80%92/"},{"title":"Siggraph2023：渲染向论文导读","text":"A Realistic Surface-based Cloth Rendering Model Paper fiber 纤维，股的组成部分 ply 股（织线的组成） yarn 纺线，n-ply yarn，n股纺线 - ply level 由ply不同的数量、缠绕的方式造成的yarn的不同外观 woven cloth 梭织 - warp-weft 经-纬 knitted cloth 针织 - knittet coth 会由于缠绕方式的不同产生体积/阴影遮挡效果，这个层级被称为pattern level BSDF 输入 几何：由于有delta transmission的需要，分为正面和反面的两组geometric texture map，贴图作为一个最小的可重复tile(&lt;256x256)，内容包括： ply法线贴图 \\(\\boldsymbol{n_p}(p)\\) ply切线贴图 \\(\\boldsymbol{t_p}(p)\\) 3D位置贴图 \\(x(p)\\) ID贴图（指定yarn的类型，比如对于梭织来说，区别经线和纬线；以及yarn之间的空白空间以产生delta transmission） \\(I(p)\\) ply中fiber的缠绕角度\\(\\omega\\)，按这个角度将ply切线贴图按ply法线贴图旋转就能得到fiber的切线方向 加入一个噪声\\(N(p)\\)来模拟前文中提到fiber构成ply的不规律性，文章中采用的是amplitude为5°的柏林噪声 着色：两个参数 albedo roughness \\(\\alpha\\)：用于描述fiber级别的scattering lobe和per fiber对于主twisting angle \\(\\omega\\)的偏移值 微观BSDF ply level 表达式： \\[ \\begin{aligned} f(x, \\mathbf{i}, \\mathbf{o}) &amp; =I(x)\\left(f^{r, s}(x, \\mathbf{i}, \\mathbf{o})+f^{r, d}(x, \\mathbf{i}, \\mathbf{o})\\right) \\\\ &amp; +I(x)\\left(f^{t, s}(x, \\mathbf{i}, \\mathbf{o})+f^{t, d}(x, \\mathbf{i}, \\mathbf{o})\\right) \\\\ &amp; +(1-I(x)) f^{\\delta}(x, \\mathbf{i}, \\mathbf{o}), \\end{aligned} \\] 前两项分别是常规的reflectance和transmission，每一项由可以进一步细分为SpongeCake lobe（通过fiber的directional scattering/reflectance，依赖于\\(x\\)点的fiber方向）和diffuse lobe（multiple scattering）；后面一项是delta transmission SpongeCake项用SGGX分布建模，由fiber切线和reflectance&amp;transmission roughness作为参数。 \\(I(x)\\)决定了delta transmission和general reflectance/transmission的比例，越接近0则transmission的部分越多 Delta transmission 之前论文忽略的一项，用于建模布料中没有scatter的光路： \\[ f^{\\delta}(x, \\mathbf{i}, \\mathbf{o})=\\frac{\\delta(\\mathbf{i}+\\mathbf{o})}{\\left\\langle\\mathbf{i} \\cdot \\mathbf{n}_{\\mathrm{s}}\\right\\rangle} \\] 这里特别解释了为什么除以了一个\\(\\left\\langle\\mathbf{i} \\cdot \\mathbf{n}_{\\mathrm{s}}\\right\\rangle\\)：因为delta transmission不会产生立体角相关的能量损耗（like other singular BSDFs），用来抵消渲染方程积分项中的\\(\\cos \\theta\\) 中尺度BSDF yarn level！ 用于补偿微观BSDF未考虑到的non-local effects。这里使用了叫做 effective BSDF的公式（用于描述一个像素覆盖的微几何的reflectance的总和）： \\[ \\begin{array}{r}f^{\\text {eff }}(\\mathbf{i}, \\mathbf{o})=\\frac{1}{A_{\\mathcal{G}}(\\mathbf{o})} \\int_{\\mathcal{P}} f(x(p), \\mathbf{i}, \\mathbf{o})\\left\\langle\\mathbf{n}_{\\mathbf{p}}(p) \\cdot \\mathbf{i}\\right\\rangle \\\\ V(x(p), \\mathbf{i}) A_{p}(p, \\mathbf{o}) k_{\\mathcal{P}}(p) \\mathrm{d} p, \\end{array} \\] 其中\\(\\mathcal{P}\\)被称为flat geometric surface patch，也就是像素中的几何表面单位集合，对应的是kernel\\(k_{\\mathcal{P}}\\)作为归一化项（集合上的积分为1）；微几何由前面的贴图参数决定： \\[ \\mathcal{G}(\\mathcal{P})=\\left\\{\\mathbf{n}_{\\mathbf{p}}(p), \\mathbf{t}_{\\mathbf{p}}(p), x(p) \\mid p \\in \\mathcal{P}\\right\\} \\] \\(V(x,d)\\)是方向\\(d\\)的二元可见性，\\(A_{\\mathcal{p}}(p,o)\\)是\\(o\\)方向可见投影区域的面积（论文里好像说错了成了AG）： \\[ A_{p}(p, \\mathbf{o})=\\frac{\\left\\langle\\mathbf{o}, \\mathbf{n}_{\\mathbf{p}}(p)\\right\\rangle}{\\left\\langle\\mathbf{n}_{\\mathbf{s}}, \\mathbf{n}_{\\mathbf{p}}(p)\\right\\rangle} V(x(p), \\mathbf{o}) \\] 最后\\(A_{\\mathcal{G}}(o)\\)是沿\\(o\\)方向的总投影面积： \\[ A_G\\left(\\mathbf{o}\\right)=\\int_{\\mathcal{P}}\\frac{\\left\\langle\\mathbf{o},\\mathbf{n_p}(p)\\right\\rangle}{\\left\\langle\\mathbf{n_s},\\mathbf{n_p}(p)\\right\\rangle}V\\left(x(p),\\mathbf{o}\\right)k\\rho\\left(p\\right)\\mathrm{d}p=\\frac{\\left\\langle\\mathbf{o},\\mathbf{n_f}(\\mathcal{P})\\right\\rangle}{\\left\\langle\\mathbf{n_s},\\mathbf{n_f}(\\mathcal{P})\\right\\rangle}, \\] 其中\\(n_f(\\mathcal P)\\)是像素中的平均可见微观法线 高效实现 出于存储空间、预计算时间和高精度纹理的支持，不对\\(f^{\\text {eff }}\\)做预计算，on flight地estimate： \\[ \\langle f^{\\mathrm{eff}}(\\mathbf{i},\\mathbf{o})\\rangle=\\frac{1}{N_{f}A_\\mathcal{G}(\\mathbf{o})}\\sum_{i=1}^{N_{f}}\\frac{f_{p}(p_{i},\\mathbf{i},\\mathbf{o})}{\\mathrm{pdf}(p_{i})}, \\] 这里直接是在\\(\\mathcal P\\)中进行uniform的采样，每次在宏观表面产生一次intersection就基于微分光线对BSDF进行计算。实际实现的时候利用了PixelSampler然后\\(N_f\\)设为1（好暴力），肯定会让方差变大，但是综合速度的考虑，以及主导的方差应该是illumination产生的，所以认为这个方案暂且可行（你说是那就是吧 however，由于\\(A_\\mathcal G\\)中的\\(n_f(\\mathcal P)\\)本身就是一个积分的结果，如果还这么玩可能会出事，所以服软选择预计算这个项。具体的方案是对position map进行降采样来最小化不同mipmap level的中尺度平均表面坡度（？），然后将他们存储为法线贴图，在渲染时进行采样。这么做的后果就是让estimator变成有偏的，因为没有考虑对于base pattern map进行的扰动（前面提到的噪声\\(N(p)\\)）。 前文提到过的二元可见性项\\(V(x,d)\\)是用来衡量shadowing和masking的，在中尺度几何上考虑局部的可见性，可以用在texture space上的水平搜索（ray marching？）来实现，但是计算量大，同时维度较高，预计算也不太可能。 解决办法是用各向异性球面高斯基（ASG）来近似每个texel的可见性： \\[ \\begin{aligned}V(p,\\mathbf{d})&amp;\\approx\\mathrm{ASG}(\\mathbf{d}|\\boldsymbol{\\mu}(p),\\gamma(p),\\sigma_X(\\boldsymbol{p}),\\sigma_y(\\boldsymbol{p}),C(\\boldsymbol{p}))&amp;(7)\\\\&amp;=C\\langle\\boldsymbol{\\mu}(p)\\cdot\\mathbf{d}\\rangle\\exp(-\\sigma_X(\\boldsymbol{p})(\\mathbf{d}\\cdot\\mathbf{x}(\\mathbf{p}))^2-\\sigma_X(\\boldsymbol{p})(\\mathbf{d}\\cdot\\mathbf{y}(\\mathbf{p}))^2)\\end{aligned} \\] 看起来和球谐函数是一个路子，但是可以存储方向性的数据，因此对于每个texel的visibility可以仅存储5个float来解决。 拟合ASG到\\(V\\) 对\\(x\\)周围的法线进行径向采样，对于每个\\(\\phi\\)都计算半径为20像素的临近像素对应的水平角度\\(\\theta(\\phi)\\in[0,\\pi/2]\\)，然后计算horizen，fit到ASG中。\\(\\mu(p)\\)由将其集中在弯曲法线以下得出（？）。剩下的几个形状参数因为发现在切线空间中的2D高斯基能提供类似的拟合，就计算这些二维高斯基的协方差矩阵，即使用协方差的在线加权，权重系数和样本对应的立体角有关。 Deep Real-time Volumetric Rendering Using Multi-feature Fusion Paper To be continued...","link":"/2023/05/15/Siggraph2023%EF%BC%9A%E6%B8%B2%E6%9F%93%E5%90%91%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB/"},{"title":"archlab 解题记录","text":"临近期末，不如来点好玩的吧 实验说明 这个 lab 的实验说明就比较劝退，我先看了开头的 Part A 部分，大致意思是，课程设置了一种新的指令集：Y86-64，相对于 x86 指令集精简了很多， 以用来进行实验，幸好的是，经过前两个 lab 的摧残，已经对汇编代码有抗性较好的认识了。 事前准备 首先使用 tar -zvf archlab-handout.tar 解压实验文件压缩包，然后运行 12cd simmake clean; make 编译工具链，期间遇到了 /usr/bin/ld: cannot find -ltk /usr/bin/ld: cannot find -ltcl 找不到两个库的错误，看了下这两个库应该是 gui 相关的，理论上来说可以直接在 makefile 里关掉，或者也可以下载安装 1apt install -y tk-dev tcl-dev Part A 进入正题，part a 主要要求我们使用 Y86 指令翻译一些 C 语言程序指令，其中需要翻译的 examples.c 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct ELE { long val; struct ELE *next;} *list_ptr;/* sum_list - Sum the elements of a linked list */long sum_list(list_ptr ls){ long val = 0; while (ls) { val += ls-&gt;val; ls = ls-&gt;next; } return val;}/* rsum_list - Recursive version of sum_list */long rsum_list(list_ptr ls){ if (!ls) return 0; else { long val = ls-&gt;val; long rest = rsum_list(ls-&gt;next); return val + rest; }}/* copy_block - Copy src to dest and return xor checksum of src */long copy_block(long *src, long *dest, long len){ long result = 0; while (len &gt; 0) { long val = *src++; *dest++ = val; result ^= val; len--; } return result;}/* $end examples */ sum_list 为了测试，我们首先编写运行框架 123456789101112131415161718192021222324.pos 0 irmovq stack, %rsp call main halt.align 8ele1:.quad 0x00a.quad ele2ele2:.quad 0x0b0.quad ele3ele3:.quad 0xc00.quad 0main: irmovq ele1, %rdi ret.pos 0x200 stack: 接下来，编写 sum 函数： 12345678910111213sum: irmovq $0, %rax andq %rdi, %rdi jmp testloop: mrmovq (%rdi), %r10 addq %r10, %rax mrmovq 8(%rdi), %rdi andq %rdi, %rditest: jne loop ret 函数逻辑很简单，不多做解释，有几个要注意的点是： Y86 指令集只支持偏移寻址，即 instant(%reg) Y86 指令集不支持直接使用内存地址来进行算数运算 rsum_list 使用递归的方法遍历链表并且将其中的值相加 12345678910111213rsum: xorq %rax, %rax andq %rdi, %rdi je return mrmovq (%rdi), %r10 addq %r10, %rax pushq %rax mrmovq 8(%rdi), %rdi call rsum popq %r10 addq %r10, %raxreturn: ret 需要注意的点：%rax 寄存器为调用者保存寄存器(caller saved register)，如果要在本函数中继续使用，需要将其 push 入栈，然后再 pop。 代码中的%r10 寄存器理论上也是调用者保存的，但是由于接下来的代码中并没有需要其保存值使用的，因此并没有将其入栈。 2020/12/6 Updated copy_block 用于从一个块中复制指定长度的内容到另一个块中，同样是使用循环结构，但是这一次需要加上条件判断，这里使用到的有： subq $0, %rdx：（pseudo）将%rdx 中的内容减去 0，设置 CF（最高位是否进位^是否是减法）、SF（结果是否为负数）、ZF（结果是否为 0），用于跳转使用（或者可以简单理解为cmp $0, %rdx，然鹅 Y86 并没有支持） jg body：如果%rdx &gt; 0，则跳转，是否跳转取决于~(SF^OF)&amp;~ZF 下面贴上 Y86 代码： 123456789101112131415161718copy_block: # src:%rdi dest:%rsi len:%rdx xorq %rax, %rax jmp tstbody: irmovq $8, %r10 mrmovq (%rdi), %r11 addq %r10, %rdi rmmovq %r11, (%rsi) addq %r10, %rsi xorq %r11, %rax irmovq $1, %r10 subq %r10, %rdxtst: xorq %r10, %r10 subq %r10, %rdx jg body ret 至此，Part A 告一段落，下面进入 Part B Part B 阅读题面： Your task in Part B is to extend the SEQ processor to support the iaddq. 很明显，这道题需要我们使用 HCL 语言来实现 iaddq 指令，即允许直接给一个寄存器加上一个立即数。参照 CSAPP 的图 4-18 我们可以做出 iaddq 的整个流程： 阶段 Opq rA, rB iaddq V, rB 取指 icode: ifun ← M1[PC] rA:rB←M1[PC+1]valP← PC+2 icode: ifun ← M1[PC]rA:rB←M1[PC+1]valC←M8[PC+2]valP←PC+10 译码 valA←R[rA]valA←R[rA] valB←R[rB] 执行 valE←valB OP valA valE←valB + valC 访存 写回 R[rB]←valE R[rB]←valE 更新 PC PC←valP PC←valP valC、valE、valP：分别代表运算所 fetch 的常数、alu 的运算结果、命令执行完后下一条命令的地址。 这么一看，iaddq 其实和 irmovq 指令是基本完全相同的，但是要指出以下两个不同点： iaddq 指令需要获取 rB 寄存器中的值参与运算，而 irmovq 则不需要。 iaddq 指令属于运算指令，需要设置 Flag 的值改变，而 irmovq 不需要。 因此总的算下来，我们在seq-full.hcl中需要区别于 IIRMOVQ 的只有两个地方： 12345678################ Decode Stage ##################################### What register should be used as the B source?word srcB = [ icode in { IOPQ, IRMMOVQ, IMRMOVQ ,IIADDQ } : rB; icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't need register]; 1234567## Select input B to ALUword aluB = [ icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ, IIADDQ } : valB; icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don't need ALU]; 结果就是将立即数与寄存器中的值相加，存回寄存器中，按照实验指导书上的指令 pass 掉了所有的 benchmark，进入下一个阶段。 Part C 2021-01-07 Updated 来填坑了！之前一直不填这个坑一是因为期末考试，二是解决期末考试之后流水线看了挺久，但是发现其实要拿分和流水线(HCL 文件)中的内容修改关系不大，除去添加 iaddq 的部分，对于pipe-full.hcl几乎不用做任何修改。 既然是利用流水线优化性能，那么就要谈到流水线处理器的几个基本优化方法： 避免寄存器冲突（提前读取减少 bubble） 减少分支跳转带来的惩罚（循环展开，以及利用总是跳转的预测原理） 源文件不再展示，这里使用了以上两个技巧得到的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154ncopy:################################################################### You can modify this portion # Loop header xorq %rax,%rax # count = 0; iaddq $-1, %rdx jne Begin mrmovq (%rdi), %r10 # read val from src... andq %r10, %r10 # val &lt;= 0? rmmovq %r10, (%rsi) # ...and store it to dst jle Done iaddq $1, %rax retBegin: iaddq $-7, %rdx jmp tst1Loop1: mrmovq (%rdi), %r10 # read val from src... mrmovq 8(%rdi), %r13 rmmovq %r10, (%rsi) # ...and store it to dst andq %r10, %r10 # val &lt;= 0? jle Npos1 # if so, goto Npos: iaddq $1, %rax # count++Npos1: rmmovq %r13, 8(%rsi) mrmovq 16(%rdi), %r10 andq %r13, %r13 jle Npos2 iaddq $1, %raxNpos2: rmmovq %r10, 16(%rsi) mrmovq 24(%rdi), %r13 andq %r10, %r10 jle Npos3 iaddq $1, %raxNpos3: rmmovq %r13, 24(%rsi) mrmovq 32(%rdi), %r10 andq %r13, %r13 jle Npos4 iaddq $1, %raxNpos4: rmmovq %r10, 32(%rsi) mrmovq 40(%rdi), %r13 andq %r10, %r10 jle Npos5 iaddq $1, %raxNpos5: rmmovq %r13, 40(%rsi) mrmovq 48(%rdi), %r10 andq %r13, %r13 jle Npos6 iaddq $1, %raxNpos6: rmmovq %r10, 48(%rsi) mrmovq 56(%rdi), %r13 andq %r10, %r10 jle Npos7 iaddq $1, %raxNpos7: rmmovq %r13, 56(%rsi) andq %r13, %r13 jle Npos8 iaddq $1, %raxNpos8: iaddq $64, %rdi # src++ iaddq $64, %rsi # dst++ iaddq $-8, %rdx # len--tst1: jge Loop1 mrmovq (%rdi), %r10 iaddq $8, %rdx andq %rdx, %rdx jg Loop retLoop: mrmovq 8(%rdi), %r13 rmmovq %r10, (%rsi) andq %r10, %r10 jle Nposs1 iaddq $1, %raxNposs1: iaddq $-1, %rdx jg Cont retCont: mrmovq 16(%rdi), %r10 rmmovq %r13, 8(%rsi) andq %r13, %r13 jle Nposs2 # if so, goto Npos: iaddq $1, %raxNposs2: iaddq $-1, %rdx # len-- jg Cont2 retCont2: mrmovq 24(%rdi), %r13 rmmovq %r10, 16(%rsi) andq %r10, %r10 jle Nposs3 iaddq $1, %raxNposs3: iaddq $-1, %rdx jg Cont3 retCont3: mrmovq 32(%rdi), %r10 rmmovq %r13, 24(%rsi) andq %r13, %r13 jle Nposs4 iaddq $1, %raxNposs4: iaddq $-1, %rdx # len-- jg Cont4 retCont4: mrmovq 40(%rdi), %r13 rmmovq %r10, 32(%rsi) andq %r10, %r10 jle Nposs5 iaddq $1, %raxNposs5: iaddq $-1, %rdx jg Cont5 retCont5: mrmovq 48(%rdi), %r10 rmmovq %r13, 40(%rsi) andq %r13, %r13 jle Nposs6 iaddq $1, %raxNposs6: iaddq $-1, %rdx # len-- jg Cont6 retCont6: rmmovq %r10, 48(%rsi) andq %r10, %r10 jle Done iaddq $1, %rax################################################################### Do not modify the following section of code# Function epilogue.Done: ret 将循环步数展开为8剩下的情况暴力处理。 大量使用了iaddq指令来减少常数写入、读出造成的损失。 把所有jmp Done的部分全部替换为ret，可以减少分支预测惩罚以及跳转所需的额外指令。 最后得到的结果不能说太好但是也是中规中矩如下 Average CPE 7.86 Score 52.7/60.0 Part C 到此结束，总结一下，这个 lab 前两个阶段没有任何难度，有手就行，但是最后一个阶段至少对于我来说还是花了不少时间来查阅资料、阅读书籍，大约花费了一天整的时间来完成，收获不少，还是非常值得花费时间来做这个 lab 的。","link":"/2020/12/01/archlab-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"“这游戏都是谁在赢？”：找到合适的竞技匹配模式","text":"前言 经常玩英雄联盟红温的经常玩多人电子竞技游戏的人应该都知道一个游戏匹配机制的重要性。但是很多时候这些迭代多年，理论上应该相当成熟的系统，总是能给我们整个眼前一黑的好活，一局游戏下来完全无法确认你的队友的显示器前坐着的到底是不是智人。 在ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games(I3D) 2024中则有一篇论文Skill-Based Matchmaking for Competitive Two-Player Games介绍了现有机制的缺陷和提出的一种全新匹配系统，笔者出于对队友智力的担忧匹配系统的兴趣，将从该论文出发，讨论现有匹配系统和评分机制。请注意，本文不是对原论文的翻译和直接总结。 什么比赛算好比赛 当然，在探讨优秀的匹配机制之前，我们应当定义比赛的精彩性。我们先以一对一的游戏为例（如国际象棋、格斗游戏和卡牌游戏等），排除那些抖S（喜欢虐菜的）和抖M（喜欢被高手虐的），大部分人喜欢的比赛应当是势均力敌的，这样的比赛一方面可以让我们享受到有来有回的竞技乐趣，另一方面通过适当的切磋总结也可以逐步提高我们的技术。 一个理想的系统应该总是为一位选手匹配到和其实力相近的对手，这首先要求系统可以对选手的实力进行量化，目前的游戏大多使用与选手账户对应的段位/排位分数\\(r\\)来衡量选手的这一指标。但是在游玩的过程中，选手的实力并不是一成不变的，系统需要逼近的理想分布为： \\[ r \\sim s(t) \\] 简单来说，系统最好在每场游戏结束后，给选手分数以恰当的变化量\\(\\Delta r\\)来让\\(r\\)快速收敛，这就是一个理想的匹配系统应该具有的性质。显而易见的，如果存在这样的理想匹配系统，并且该系统中的选手数量足够多且选手实力满足类正态分布时，所有选手的胜率的期望值\\(E[f_E] = 0.5\\)，这应该通过以下两点实现，同时也是需要实际系统解决的两个问题： 将选手的实力正确评估为分数，并且能让该分数随时间快速收。 将分数相近的选手匹配到同一局游戏中。 How-to 对于单人竞技类游戏而言，问题2可以直接对单个选手的分数进行近似匹配解决，而有多个系统被提出以解决问题[1]。 “臭名昭著”的Elo Rating System Arpad Elo在1978年出版的书籍The Rating of Chess Players Past and Present中首次提出了Elo系统（没想到吧，Elo其实是人名），这一系统因为被英雄联盟采用而广为人知，而对该系统谣传的误解通常如下： Elo系统会给胜率高的人匹配胜率低的队友，来将所有人的胜率拉至接近50%的水准。 实际上，这一误解存在两点问题： 所有人的胜率的期望值接近50%是任何竞技系统的最终目的，无关Elo或者其他系统。 Elo系统最初设计是用于国际象棋的评分，不涉及任何多人匹配的内容。 在这一点上达成共识后，我们就可以真正开始对初版Elo的介绍了。Elo致力于解决的是估计胜率和分数更新两个问题，首先考虑两个对战选手A、B的分数为\\(r_A\\)和\\(r_B\\)，那么在一场游戏中，A战胜B的概率为： \\[ f_E(A, B) = \\frac{1}{1 + 10^{-(r_A - r_B) / 400}} \\] 👆在\\(r_B = 200\\)时，A的胜率随\\(r_A\\)的变化 该函数有两点优秀的性质： \\(f_E(A, B) + f_E(B, A) = 1\\)，即该概率函数具有一致性。 两者的胜率与自身分数的绝对值无关，仅与差值\\(|r_A - r_B|\\)和缩放系数\\(400\\)相关。 假设系统在\\(m\\)场比赛后，根据该系列赛的数据来更新选手的分数，具体的更新公式为： \\[ r'_A = r_A + K \\sum_{i}^{m} \\left( s_i - f_E(A, i) \\right) \\] 其中\\(K\\)是固定的分数更新常量，\\(s_i\\)代表比赛胜负带来的积分，赢、负、平分别为1、0和0.5分。这个更新的过程是符合直觉的：当一个选手在越没有可能战胜另外一个选手获胜时，得到的分数越多，当已经是在虐菜时，则几乎不得分。该过程类似于梯度下降，通过一个batch的学习来更新参数。 但是Elo初始方法的缺点也很明显： 胜率和分数均通过一个常数400（可更改）控制，如何合理地给与选手初始分数值得商榷。 分数更新的系数\\(K\\)固定，并且不随游戏过程发生变化，如何选择一个合适的值使其在一名选手的前期不至于收敛过慢、后期不至于导致变化过于剧烈无法衡量。 该系统没有考虑选手对于对战的偏好性，若出现类似于环状的关系：A选手的风格正好压制B，而B压制C，C压制A，系统则难以收敛。 该系统基于部分群体（与A比赛的人）来衡量A的实力，没有考虑整个选手群体的情况。 Glicko Rating Systems Glickman在1999年提出了Glicko rating system，该系统在Elo的胜率估计和分数更新上加入了额外的评分误差函数\\(g(\\phi)\\)来让系统更容易收敛，具体的公式就不贴了。简单来说Glicko系统通过引入更复杂的\\(g(\\phi)\\)和\\(K_G\\)来让选手的分数后期更具有收敛稳定性，减少了需要人为选择的常量。 但是该系统仍然未能解决Elo系统存在的问题[3]和[4]，并且新的胜率函数\\(f_G\\)不具有一致性（和非1）。 多人游戏中的Elo TBC，如果有人看的话。。。","link":"/2024/10/07/%E2%80%9C%E8%BF%99%E6%B8%B8%E6%88%8F%E9%83%BD%E6%98%AF%E8%B0%81%E5%9C%A8%E8%B5%A2%EF%BC%9F%E2%80%9D%EF%BC%9A%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84%E7%AB%9E%E6%8A%80%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F/"},{"title":"一次WSL上使用clangd编写cuda的踩坑","text":"起因 最近在WSL上学习CUDA，不假思索地选择了clangd作为lsp，使用的软件如下： Arch WSL2 CMake 3.28.1 Cuda compilation tools, release 12.3, V12.3.103 LLVM 16.0.6 VSCode 1.85.1 但是使用的过程中，遇到了一个非常神秘的问题，对于C++的源代码*.h和*.cpp等，clangd的代码补全一切正常，但是一遇到.cu文件，completion的延迟会长达几秒钟： 可以看到连copilot都已经给我写好了，但是clangd还在犹豫，这是为什么呢？我看了一眼compile_commands.json，发现并没有异样。遂在互联网上搜索了一番，最终在某群中，一个群友给出建议： 先在sudo模式下把 /etc/wsl.conf 文件权限+w，然后在该文件下新建节 [interop] enabled = false appendWindowsPath = false 最后重启wsl 看来果然是WSL的锅，经过一番控制变量，发现问题出在了$PATH的环境变量上，WSL的$PATH环境变量会自动添加Windows的环境变量，众所周知垮WSL的Host IO非常拉胯，在一堆/mnt路径中搜来搜去肯定是很慢的。 But How? 但是很明显，这是不应该出现的情况，而且我也不想把interop直接禁用掉。 再次检查compile_commands.json，一切正常： 123456{ &quot;directory&quot;: &quot;/home/carbene/Projects/HiCuda/build&quot;, &quot;command&quot;: &quot;/opt/cuda/bin/nvcc -forward-unknown-to-host-compiler -DCMAKE_INTDIR=\\\\\\&quot;RelWithDebInfo\\\\\\&quot; -I/home/carbene/Projects/HiCuda/common/includes -I/home/carbene/Projects/HiCuda/build/_deps/fmt-src/include -O2 -g -DNDEBUG -std=c++20 \\&quot;--generate-code=arch=compute_75,code=[compute_75]\\&quot; -x cu -rdc=true -c /home/carbene/Projects/HiCuda/course3/memory_accessing.cu -o course3/CMakeFiles/course3_memory.dir/RelWithDebInfo/memory_accessing.cu.o&quot;, &quot;file&quot;: &quot;/home/carbene/Projects/HiCuda/course3/memory_accessing.cu&quot;, &quot;output&quot;: &quot;course3/CMakeFiles/course3_memory.dir/RelWithDebInfo/memory_accessing.cu.o&quot;} 根本没有任何/mnt路径出现，不见棺材不掉泪，我把LLVM的源码拉了下来，对着$PATH一顿搜索，毫无头绪，用到了$PATH的地方根本就没有被触发。幸运的是，发现vscode-clangd有一个trace的配置，可以保存trace到一个可以被Chrome trace viewer打开的文件中，very well，对比有无清理$PATH的trace结果： 瓶颈在CreatePreamblePatch： 一开始以为是clangd的include search问题，但是经过二分排查法，瓶颈调用链竟然出现在clangd对于nvcc的调用上，但是我的compile_commands.json中的nvcc就是在WSL中的。由于后续debug涉及到了LLVM核心模块，因此不再深究。但是综合上述的情况，答案很明显了： 瓶颈并非clangd，而是nvcc，nvcc会在被调用时对于$PATH进行搜索，而$PATH中包含了/mnt路径，导致了严重的IO延迟（这也是为什么只有.cu文件会有问题）。 So **** u, NVIDIA. 解决方案 真麻烦，我们肯定不能指望哪一天NVIDIA大发慈悲来修修这个问题，而我目前也还没有找到能限制nvcc搜索路径的方法，因此只能从vscode-clangd插件入手。解决办法也很直接：在其启动clangd language server时清理一下$PATH即可： 在vscode-clangd的src/clangd-context.ts中： 1234567891011121314151617181920212223242526diff --git a/src/clangd-context.ts b/src/clangd-context.tsindex 0fef3f5..9e1ceb2 100644--- a/src/clangd-context.ts+++ b/src/clangd-context.ts@@ -71,10 +71,20 @@ export class ClangdContext implements vscode.Disposable { args: await config.get&lt;string[]&gt;('arguments'), options: {cwd: vscode.workspace.rootPath || process.cwd()} };++ let processEnv = process.env;+ let envPath = processEnv.PATH;+ if (envPath) {+ let pathArray = envPath.split(':');+ pathArray = pathArray.filter(path =&gt; !path.startsWith('/mnt'));+ processEnv.PATH = pathArray.join(':');+ } const traceFile = config.get&lt;string&gt;('trace'); if (!!traceFile) {- const trace = {CLANGD_TRACE: traceFile};- clangd.options = {env: {...process.env, ...trace}};+ const trace = { CLANGD_TRACE: traceFile };+ clangd.options = { env: { ...processEnv, ...trace } };+ } else {+ clangd.options = { env: processEnv }; } const serverOptions: vscodelc.ServerOptions = clangd; 总而言之，虽然最终没能完美解决这个问题，但是能发现问题的根源然后用一个比较tricky的方法解决掉，也是一件值得庆幸的事情。 以及，again，**** u, NVIDIA.","link":"/2023/12/17/%E4%B8%80%E6%AC%A1WSL%E4%B8%8A%E4%BD%BF%E7%94%A8clangd%E7%BC%96%E5%86%99cuda%E7%9A%84%E8%B8%A9%E5%9D%91/"},{"title":"从物体空间到屏幕：深入理解变换矩阵","text":"前言 最近在学习写一个离线渲染器的时候，有一个需求是要实时地追踪一条射线逐个打到的物体然后显示debug信息的功能（顺便一说，这个功能真的很好用也很好玩），离线部分仿照的pbrt-v3，交互的前端则是使用的imgui+OpenGL。前面的实现都很顺利，但是到渲染车辆场景的时候，发现射线没有做到指哪打哪，那肯定是出问题了，于是我从头到尾地排查了一遍所有的变换相关的代码。发现了两个问题： OpenGL中裁剪空间的Z轴范围要求范围为\\([-1, 1]\\)，而pbrt的perspective矩阵变换的Z范围为\\([0, 1]\\)。 OpenGL需要在NDC之前就考虑viewport的长宽比aspect，但是pbrt将这一步推迟至了cameraToRaster。 进行排查的同时也系统化地解决了大量疑问： 老生常谈的MVP矩阵到底是在哪些空间中进行变换？ 变换的结果范围是什么？ 用的是左手还是右手坐标系？ ... 作为一个总结，这篇博文会对图形学中的矩阵变换进行一次统一的梳理以加深理解，并且能够成功解答这些疑问。 左手系vs右手系 要定义一套坐标系统，一个前提就是确定坐标系的三个基单位向量，这三个向量必然是线性无关并且两两正交的。当确定了其中的两个向量（x、y）后第三个向量的确定就有两个方向可以选择了，这两个方向是正好相反的，因此就诞生了有了左手系和右手系的区别。 确定左右手系的方法如其名，用大拇指代表x向量，用食指代表y向量，分别指向右侧和上方，然后剩下的中指就是z向量，这三个向量两两正交，因此左右手会自然呈现出两种不同的形态： 左右手系 叉乘？ 需要注意的是，在这两种坐标系下，叉乘的定义都是不变的，即对于\\(\\vec v_1 = (x_1, y_1, z_1)\\)和\\(\\vec v_2 = (x_2, y_2, z_2)\\)，有： \\[ \\vec v_1 \\times \\vec v_2 = (y_1z_2 - z_1y_2, z_1x_2 - x_1z_2, x_1y_2 - y_1x_2) \\] 谁在用这些坐标系？ 在一般生活中，我常见到的坐标画法是右手系，但是图形学的应用中两种手系均有人使用，比如pbrt使用的就是左手系。一个常见的谬误就是可编程管线中OpenGL或者DirectX使用了某一个特定的坐标系。实际上，只有固定功能管线才会使用固定的坐标系，如OpenGL2.0以前的版本使用的是右手系，而DX9默认使用的是左手系（可更改）；而在可编程管线中，管线在顶点着色器之后经过固定的透视除法得到的NDC坐标就已经和左/右系无关了，NDC中的z轴范围为\\([-1, 1]\\)，越小离相机越近，越大离相机越远，这个定义是固定的，和左右手系完全无关。 但是用户在进行VP坐标变换的时候则必须自己考虑坐标系的问题，这个问题会在接下来的内容中详细讨论。 从物体空间到世界空间 用过Unity的人应该对ObjectToWorld这个矩阵很熟悉，通常这个矩阵被用在有层级的物体上。这样就可以将子物体的坐标系变换到父物体的坐标系中，再由父物体变换到世界坐标系中，这样就可以得到子物体在世界坐标系中的坐标了。 这也就是MVP中的M，模型矩阵。 从世界空间到相机空间 接下来，我们需要从相机的方向观察世界坐标中的所有点，为了简化操作，这一步的具体过程就是假设将相机放置于原点\\((0, 0, 0)\\)，然后沿着z轴观察世界。我们需要做的就是找出这个相机的坐标系，然后将所有的点变换到这个坐标系中，这一步中常用的方法是被称为lookat的矩阵，具体组成如下： LookAt矩阵 需要求的几个向量分别是Right(x)、Up(y)、Direction(z)和Position，已知Position、Direction是确定的（前者是相机位置，后者是需要给定的参数），使用用户传入的\\(U'\\)确定一个平面来构建Right，接下来的工作就是求出\\(R\\)和\\(U\\)两个向量。 那么问题就来了，我知道\\(R\\)向量是由\\(U'\\)和\\(D\\)叉乘得到的，那么叉乘的顺序应该是什么呢？这里就涉及到了坐标系的手性问题了。在左手系中，我们将相机放置在原点，并且使其看向\\(z\\)轴正方向；右手系则反之，使其看向\\(z\\)轴负方向。 让我们看看glm中的左、右手系是怎么求这三个向量的： 12345678910111213141516171819202122232425262728293031323334template&lt;typename T, qualifier Q&gt;GLM_FUNC_QUALIFIER mat&lt;4, 4, T, Q&gt; lookAtLH(vec&lt;3, T, Q&gt; const&amp; eye, vec&lt;3, T, Q&gt; const&amp; center, vec&lt;3, T, Q&gt; const&amp; up){ vec&lt;3, T, Q&gt; const f(normalize(center - eye)); vec&lt;3, T, Q&gt; const s(normalize(cross(up, f))); vec&lt;3, T, Q&gt; const u(cross(f, s)); ... return Result;}template&lt;typename T, qualifier Q&gt;GLM_FUNC_QUALIFIER mat&lt;4, 4, T, Q&gt; lookAtRH(vec&lt;3, T, Q&gt; const&amp; eye, vec&lt;3, T, Q&gt; const&amp; center, vec&lt;3, T, Q&gt; const&amp; up){ vec&lt;3, T, Q&gt; const f(normalize(center - eye)); vec&lt;3, T, Q&gt; const s(normalize(cross(f, up))); vec&lt;3, T, Q&gt; const u(cross(s, f)); mat&lt;4, 4, T, Q&gt; Result(1); Result[0][0] = s.x; Result[1][0] = s.y; Result[2][0] = s.z; Result[0][1] = u.x; Result[1][1] = u.y; Result[2][1] = u.z; Result[0][2] =-f.x; Result[1][2] =-f.y; Result[2][2] =-f.z; Result[3][0] =-dot(s, eye); Result[3][1] =-dot(u, eye); Result[3][2] = dot(f, eye); return Result;} 对于右手系，\\(R = D \\times U'\\)，","link":"/2023/06/28/%E4%BB%8E%E7%89%A9%E4%BD%93%E7%A9%BA%E9%97%B4%E5%88%B0%E5%B1%8F%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"title":"从零开始写一个光栅软渲染器","text":"结束了GAMES101的学习（好久了，又因为大作业的毛发渲染由于生病暂时没法摸到自己的电脑，突发奇想的能不能做一个光栅渲染器（因为做raytracer的人实在太多力），于是便开了一个仓库来放相关的东西：Tiny Rasterizer 渲染管线 pipeline 这里，我们实现的时候因为偷懒因为方便，我只实现了以下的部分： 顶点定义 顶点变换 光栅化 片元着色 样本操作（暂未实现） 目前的效果还是不错的，具体的实现细节可以参考我上面列出的GitHub代码。 踩坑日记 OBJ的mesh三角化 最开始我是直接从GAMES101的作业3的框架里把三角形的加载代码抄了过来，后面加载顶点数大于3的face时出现了非常严重的错误（是的，非常严重），研究了一番后发现是没有根据OBJ_Loader的内部下标来读取，更改之后就好了。 法线的变换 首先，要清楚的是法线是不归由于透视投影或者正交投影而发生改变，投影前后是保持一致的；其次，法线的变换是\\(((M_{view}\\cdot M_{model})^{-1})^T\\)，具体推导过程也非常简单，此处不再赘述。 贴图坐标 一开始，我直接用贴图的(u, v)坐标做双线性插值，结果十分奇怪，贴图出现了各种错位，后面经过考证，发现贴图坐标是从左下角开始算的（发现之后真的蚌埠住了），于是对v进行修正之后正常。 额外需要注意的是，tga文件本身作为贴图的时候已经进行了uv坐标的换算了，也就是说这个时候我们反而需要在读取的时候对整个文件做一个y方向的flip才行。 Objective-C++&amp;C++混合编译链接 不知道什么原因，在引入了mm文件之后，hpp文件就不能直接定义裸奔的函数了，解决的方法也很简单，就是函数定义和实现分开到.hpp和.cpp中即可。 左右颠倒？ 昨天发现我试图渲染出来的图片是左右颠倒的，查了半天发现问题出现在投影矩阵和y坐标的换算上，首先投影矩阵的near和far在计算camera的width和height的时候需要取相反数，这里的原因是摄像机是从z正半轴往负半轴看去，近、远平面其实都是位于负半轴上的；其次世界y坐标正方向向上，屏幕的y坐标正方向向下，需要颠倒一下。 大三角形平面无法显示 这是跟NDC空间、透视空间变换有关系的，当一个点在摄像机后方时，经过mv变换后，得到的\\(z\\)坐标分量是一个负数，这个时候通过透视变换之后得到的\\(w\\)分量也一定是一个负数，由于在mvp变换之后有一个除以\\(w\\)的透视除法，这个时候我们得到的Vec3(x, y, z)中的前两个分量将会正好是正确坐标值的相反数（为什么z分量不是？因为他本身就是负的！）所以我们需要在判断\\(w\\)分量为负的时候将前两个分量取各自的相反数才能得到正确的坐标值。 RoadMap 目前这个光栅化渲染器已经大概能用了（虽然我知道还藏着很多bug），但是由于每次都需要dump到图片中进行预览，效率很低，接下来打算通过窗口化的方式来提高debug效率。","link":"/2021/11/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%89%E6%A0%85%E6%B8%B2%E6%9F%93%E5%99%A8/"},{"title":"从零开始在Blender中导出布料动画到GLTF&#x2F;USD","text":"本文记录一个菜鸡完整的在Blender中创建布料动画并导出为glTF/USD格式的过程，作为笔记供后续查阅。 创建布料动画 本部分完全参考Gemini给出的流程（不得不说Gemini已经强到可以教人用Blender的程度了）： 在Blender中制作“风吹晾衣绳上的床单”是布料模拟（Cloth Simulation）的一个经典案例。这涉及到三个核心环节：布料设置（Cloth）、固定点（Pinning）和风力场（Wind Force Field）。 以下是详细的分步教程： 第一步：场景建模 (Modeling) 创建床单： Shift + A 新建一个 Plane (平面)。 R -&gt; X -&gt; 90 将其立起来。 S -&gt; X 拉宽，使其变成长方形（像床单一样）。 细分网格 (至关重要)： 布料需要足够的顶点才能弯曲。 选中平面，进入 Edit Mode (Tab键)。 右键 -&gt; Subdivide (细分)。在左下角菜单中，将 Number of Cuts 设为 50 或更高（网格越密，褶皱越细腻，但计算越慢）。 创建晾衣绳： 回到 Object Mode。 Shift + A 新建一个 Cylinder (圆柱体)。 将其旋转、缩放，做成一根细长的棍子，放在床单的上方边缘处。 第二步：设置固定点 (Pinning) 这是让床单“挂”在绳子上而不是掉下去的关键。 选中床单，进入 Edit Mode。 如果你希望床单是搭在绳子上：选中床单中间的一排顶点。 如果你希望床单是被夹子夹住：选中床单顶部边缘的两个或多个点（模拟夹子的位置）。 设置顶点组： 在右侧属性面板，点击绿色倒三角图标 (Object Data Properties)。 在 Vertex Groups 栏点击 + 号。 将其命名为 \"Pin\"（或者\"Holder\"）。 点击 Assign 按钮（此时权重 Weight 为 1.0）。 回到 Object Mode。 第三步：添加物理属性 (Physics) 给晾衣绳添加碰撞： 选中晾衣绳。 在右侧属性面板，点击蓝色圆圈图标 (Physics Properties)。 点击 Collision (碰撞)。这样床单碰到绳子时不会穿过去（如果你的固定点做得很好，这一步可以选做，但加上更真实）。 给床单添加布料系统： 选中床单。 点击 Physics Properties -&gt; Cloth (布料)。 关键设置 1 (Shape)： 向下滚动找到 Shape 选项卡。 在 Pin Group 中，选择刚才创建的 \"Pin\" 顶点组。 解释：这告诉Blender，除了这些被选中的点不动（或跟随父级），其他部分都要受重力影响掉下来。 关键设置 2 (Collisions)： 向下滚动找到 Collisions。 勾选 Self Collisions (自碰撞)。这非常重要，否则风吹的时候床单会穿插进自己身体里。 第四步：添加风场 (The Wind) Shift + A -&gt; Force Field (力场) -&gt; Wind (风)。 使用 G (移动) 和 R (旋转) 将风场放置在床单的侧面或正面，箭头指向床单。 调整风力参数： 选中风场对象，去右侧属性面板（最后一个图标 Physics）。 Strength (强度)： 默认值太小，对于布料通常需要设为 1000 到 5000 甚至更高，取决于你的场景比例。 Noise (噪波)： 设为 1.0 到 5.0 之间。 解释：Noise非常重要，它让风忽大忽小，产生自然的“飘动感”，而不是像吹风机一样死板地吹。 第五步：调整与运行模拟 播放动画： 按下 Space (空格键) 播放。你应该能看到床单下垂，并被风吹动。 注意：如果电脑卡顿，这是正常的，布料解算需要时间。 美化床单外观： 选中床单，右键 -&gt; Shade Smooth (平滑着色)。 在右侧 Modifier Properties (蓝色扳手) 面板： 布料修改器(Cloth)应该在最上面。 添加 Solidify Modifier (实体化)：增加一点 Thickness (厚度)，让床单看起来不是纸片。 添加 Subdivision Surface (表面细分)：放在最后，让褶皱更圆润。 微调物理参数 (Cloth Settings)： Stiffness / Tension: 如果床单看起来像橡胶，增加 Tension (张力)。 Damping (阻尼): 如果床单抖动得太厉害，增加 Air Viscosity (空气粘滞度) 或 Damping。 Quality Steps: 如果穿模严重，将 Cloth 设置最上方的 Quality Steps 从 5 提高到 10 或 12。 进阶技巧 (让效果更真实) 模拟夹子运动： 如果你想做夹子夹住床单的效果，你可以创建夹子模型，然后使用 Vertex Parenting (选中夹子，选床单，进编辑模式选顶点，Ctrl+P -&gt; Make Vertex Parent)，这样夹子就会跟着布料的那个点一起晃动。 烘焙 (Baking)： 当你对效果满意后，在布料设置的 Cache 选项卡下，点击 Bake。这样Blender会把运算结果存入内存/硬盘，之后拖动时间轴就会非常流畅，渲染时也不会出错。 常见问题排错 床单穿过绳子了？ 检查绳子是否加了 Collision，或者增加布料的 Collision Quality。 风吹不动？ 增加 Wind 的 Strength，或者检查风的箭头方向是否对准了床单。 床单掉下去了？ 检查 Cloth 设置里的 Pin Group 是否选中了正确的顶点组。 效果（这里没有固定床单）： 烘焙为顶点动画 由于大部分目标格式glTF/USD都不支持Blender的物理模拟系统，所以我们需要先把布料动画烘焙成顶点动画（Vertex Animation），这一步是通过导出为MDD格式实现的。首先从Blender的插件市场安装 NewTek MDD Format： 在Blender完成Bake布料动画之后，记得在第一帧按 Ctrl + A Apply Transform 应用变换。此时确保你的modifiers都是启用的状态（比如Solidify和Subdivision），然后选中布料对象，点击 File -&gt; Export -&gt; MDD (.mdd)，选择一个路径保存MDD文件。这里启用modifier的目的是让烘焙的顶点动画包含所有修改器的效果，而不仅仅是原始的布料模拟结果。 因为带shape key的模型无法再应用modifier，所以在导入MDD之前需要先把Subdivision和Solidify的效果Apply到模型上。Cloth模拟的结果已经烘焙到顶点动画里了，所以可以直接删掉这个modifier。 此时选中床单，把刚刚导出的MDD文件导入到这个对象上，会发现动画已经成功地应用到模型上了： 对应的，Data-Shape Keys也会出现一堆关键帧。 导出为glTF/USD 这一步没什么好说的，和普通的流程类似。需要注意的是虽然两者都提供了基于weight的顶点动画支持，大部分第三方软件比如f3d等对于glTF的顶点动画支持都非常有限，所以如果需要在其他软件中使用，建议导出为USD格式。","link":"/2026/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%9C%A8Blender%E4%B8%AD%E5%AF%BC%E5%87%BA%E5%B8%83%E6%96%99%E5%8A%A8%E7%94%BB%E5%88%B0GLTF-USD/"},{"title":"使用Rust编写HTTP服务器","text":"简述 最近通过 rust book 学习 rust，根据最后一章的内容制作了一个简单的异步 http 服务器。 项目结构 |-- hanabi |-- .gitignore |-- 404.html |-- Cargo.lock |-- Cargo.toml |-- hello.html |-- src |-- lib.rs |-- main.rs |-- target ​ |-- .. 代码部分 main.rs 1234567891011121314fn main() { // returns a TcpListener instance(wrapped by Result&lt;T,E&gt;) let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap(); let pool = ThreadPool::new(4); // iterate to fetch the incoming tcp connection // store the tcp connection inside stream // it's currently synchronized. for stream in listener.incoming() { let stream = stream.unwrap(); pool.execute(|| { handle_connection(stream); }); }} main函数部分，我们设计了一个ThreadPool来实现同步地接受多个请求，在每次接受到一个listener.incoming()的请求时，都把他转化为一个stream后在 pool 里进行execute，handle方法如下： 1234567891011121314151617fn handle_connection(mut stream: TcpStream) { let mut buffer = [0; 1024]; stream.read(&amp;mut buffer).unwrap(); let (get, sleep) = (b&quot;GET / HTTP/1.1\\r\\n&quot;, b&quot;GET /sleep HTTP/1.1\\r\\n&quot;); let (filename, status_line) = if buffer.starts_with(get) { (&quot;hello.html&quot;, &quot;HTTP/1.1 200 OK\\r\\n\\r\\n&quot;) } else if buffer.starts_with(sleep) { thread::sleep(Duration::from_millis(10000)); (&quot;hello.html&quot;, &quot;HTTP/1.1 200 OK\\r\\n\\r\\n&quot;) } else { (&quot;404.html&quot;, &quot;HTTP/1.1 404 NOT FOUND\\r\\n\\r\\n&quot;) }; let body = fs::read_to_string(filename).unwrap(); let response = format!(&quot;{}{}&quot;, status_line, body); stream.write(response.as_bytes()).unwrap(); stream.flush().unwrap();} 注：这里需要注意buffer开的大小，太小可能导致服务器的一条线程直接死亡（需要处理错误，但是因为直接unwrap掉了所以会导致线程挂起） lib.rs 1234pub struct ThreadPool { workers: Vec&lt;Worker&gt;, sender: mpsc::Sender&lt;Message&gt;,} 首先定义前文中需要用到的ThreadPool，由负责执行任务的workers以及给worker派发任务的sender组成。 1234struct Worker { id: usize, thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,} Worker类用于包装thread类，以下是Worker::new()方法 1234567891011121314151617181920fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker { let thread = thread::spawn(move || loop { let message = receiver.lock().unwrap().recv().unwrap(); match message { Message::NewJob(job) =&gt; { println!(&quot;Worker {} got a job; executing&quot;, id); job(); } Message::Terminate =&gt; { println!(&quot;Worker {} was told to stop&quot;, id); break; } } }); Worker { id, thread: Some(thread), } } 我们使用thread::spawn(move || loop)来产生一个循环的线程，通过不停地获取receiver中的请求，通过match来对不同的请求作出响应，要注意的是，由于我们的需求是：跨线程共享同一对象、同一时间只能被一条线程引用，因此我们需要使用原子变量Arc&lt;T&gt;，来使得变量安全地在线程之间共享，注意Arc&lt;T&gt;作为一个类似于指针的作用，是开箱即用的。另外，由于thread被Option&lt;T&gt;包裹，所以需要使用Some(thread)来创建。 12345enum Message { NewJob(Job), Terminate,}type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;; 这里回忆一下Box&lt;T&gt;：类似于C++中的智能指针，Box负责从 heap 上分配内存，并且将T类型的对象放置于其上（rust 中的对象默认是分配在栈上的）。dyn则表示对象是动态分发的基类trait；Send表示该对象可以在线程间安全地传递 ownership，可以作为跨线程共享的 marker；FnOnce表示该方法只能被调用一次。 接下来我们详解一下ThreadPool部分的方法实现： ThreadPool::new 123456789101112pub fn new(size: usize) -&gt; ThreadPool { assert!(size &gt; 0); let (sender, receiver) = mpsc::channel(); let receiver = Arc::new(Mutex::new(receiver)); let mut workers = Vec::with_capacity(size); for id in 0..size { workers.push(Worker::new(id, Arc::clone(&amp;receiver))); } ThreadPool { workers, sender }} ThreadPool的创建，对于每一个即将进入workers队列中的方法我们都会对其进行初始化，这里就不需要每次都去 new 一个 receiver 了，而是可以直接使用Arc::clone方法来进行实现。 ThreadPool::execute 12345678pub fn execute&lt;F&gt;(&amp;self, f: F) where F: FnOnce() + Send + 'static, { let job = Box::new(f); self.sender.send(Message::NewJob(job)).unwrap(); } 首先，我们定义了执行方法f: F，供我们调用，因为之前job方法是分配在堆上的，所以需要使用Box包裹起来。 小结 跟着官网做完这个例子之后，感觉看书的时候还是有很多知识点其实并不完全了解清楚，所以果然编程还是的多靠实践啊，后续也许会继续进行优化改进，并且同步更新 rust 的学习笔记。","link":"/2020/07/07/%E4%BD%BF%E7%94%A8Rust%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"使用bucket tree进行层级化数据的存储","text":"对于诸如域名一类的有限层级的数据，我们提出一种数据结构Bucket Tree来进行数据的树形存储 传统的域名为明显的有限的分级结构，形如mail.bupt.edu.cn，我们需要一种可靠的数据结构来进行存储。以域名的存储为例，有以下的特点： 有限层级: 域名最多只有 127 级 一次性写入，多次读出: 服务器会在开启时一次性读入硬盘上所有域名记录，且之后几乎没有新增操作 重叠性强: 对于类似于com的顶级域名极有可能被多个二级域名重复引用，如baidu.com, google.com Bucket Tree 桶树是一种结合了多叉树与哈希集的数据结构，其中哈希集使用链地址查找法，平均查找、插入复杂度为O(1)，则对于一个m层的树，查找效率为O(m)，由于在 dns 的语境下，\\(m = 127\\)，则效率为O(1)。 具体代码等咕咕完 dns 再发:-P","link":"/2021/04/27/%E4%BD%BF%E7%94%A8bucket-tree%E8%BF%9B%E8%A1%8C%E5%B1%82%E7%BA%A7%E5%8C%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"},{"title":"信号图像处理：傅立叶变换与频域分析","text":"最近在QQ群里看到了下列一则消息： 豆瓣在网页和APP中加入盲水印 可追踪截图用户 豆瓣在15日于其网页版标题下方加入了一行小字，内容是uid、tid和截图时间。这些文本颜色与网页背景色大体接近，肉眼无法直接分辨，如果有人截图通过调节对比度就可以显现出来。豆瓣可以轻松追踪截图者是谁。 在被曝光后豆瓣已将该部分设置为禁止选中。另外豆瓣早在2021年已经在其App中加入了类似功能。 隐写技术并不是新鲜事，其它互联网公司也早有应用，甚至更加先进。 在此前阿里巴巴月饼事件中泄露内网截图的员工虽然对图片做了处理，但是依然可以通过频域手段添加的数字盲水印精确定位到泄密员工。知乎用户 fuqiang liu 经过测试，使用涂抹，剪切，放缩，旋转，压缩，加噪，滤波等手段无法过滤这种盲水印，唯一的办法是对屏幕拍照。但是，依然可以通过文本间距等手段区分不同用户。审查者在这方面有很多技术选项。 有不少同学十分好奇其中提到的“通过频域手段添加的数字盲水印”是如何实现的。对于初学者而言也确实很难将一张图片与所谓的频率联系起来，那么到底什么是数字图像的频域分析呢？ 傅立叶变换 引用一段Wiki对于傅立叶变换的介绍： 傅里叶变换（法语：Transformation de Fourier、英语：Fourier transform）是一种线性积分变换，用于信号在时域（或空域）和频域之间的变换，在物理学和工程学中有许多应用。因其基本思想首先由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。实际上傅里叶变换就像化学分析，确定物质的基本成分；信号来自自然界，也可对其进行分析，确定其基本成分。 可知，傅立叶变换做的工作就是把一段信号从时空域搬到频域上，频域自然就是指根据不同频率分布的数值，那么这个频率到底指什么的频率？傅立叶级数告诉了我们如下的答案： 在对傅里叶级数的研究中，复杂的周期函数可以用一系列简单的正弦、余弦波之和表示。傅里叶变换是对傅里叶级数的扩展，由它表示的函数的周期趋近于无穷。 wiki上用了一张图相当形象地展示了这一过程： 即，我们将以时间变换的x轴替换为了根据频率变换的x轴，而同一个三角函数的频率是不变的，所以频域空间上得到的是一条条线段。 傅立叶也为我们提供了一个方便的公式来进行傅立叶变换（连续），对于可积分的函数\\(f\\)： \\[\\hat{f}(\\xi)=\\int^\\infty_{-\\infty}f(x)\\exp{(-2\\pi ix\\xi)}\\text{d}x\\] 这样，我们可以再通过欧拉公式把其变为正弦、余弦函数的组合，即做到了将所有的函数都转换到频域上的需求。 离散傅立叶变换 可是如果仅仅知道连续傅立叶变换，并不能很好地解决我们的问题，毕竟图像由一个个像素组成，属于离散信号，这个时候应该怎么做傅立叶变换呢？很简单，类似于黎曼积分，对于\\(N\\)点序列\\(\\{x[n]\\}_{0\\le n \\le N}\\)，离散傅立叶变化为： \\[\\hat{x}[k] = \\sum^{N-1}_{n = 0}\\exp{(-i\\frac{2\\pi}{N}nk)x[n]}\\] 图像的傅立叶变换 虽然傅立叶变换看起来很美好，可以描述任意信号的频域分布，但是一张图片不能是一条线组成的啊，这里就需要用到二维的傅立叶变换了，所谓二维傅立叶变换，也不过是在空域的\\(x\\)轴再加上一个\\(y\\)的维度，这里我们只讨论离散情况： \\[F(u, v) = \\sum^{M-1}_{x=0}\\sum^{N-1}_{y=0}f(x,y)\\exp{(-j2\\pi(ux/M+vy/N))}\\] \\[\\exp{(-j2\\pi(ux/M+vy/N))} = \\cos\\theta + j\\sin\\theta, \\theta = 2\\pi(ux/M+vy/N)\\] 那么应该怎么确定一个正弦/余弦平面波？首先肯定的，有三要素：频率\\(\\omega\\)，幅度\\(A\\)，相位\\(\\phi\\)，同时，平面有着一维函数不具有的性质：方向\\(\\vec{n}\\)，即两个平面波可以拥有相同的三要素，但是却像海浪一样，拥有不同的波动方向。 K空间 将一个二维函数分解为平面波之后，我们应该怎么形象地可视化这些波的不同分布呢？已知每个波有不同的法向量\\(\\vec{n}\\)，频率\\(\\omega\\)，那不如就用这两者构建一个空间，这个空间中的一个坐标点\\((u,v)\\)代表了在法向量\\(\\vec{n} = normalize(u, v)\\)方向下，频率为\\(\\sqrt{u^2 + v^2}\\)的一个波，每个波用0-1表示幅度，即可构建一个k空间矩阵，用来存储各个波的分布，这样，我们就可以很自然地得到一个中心代表低频、四周代表高频、不同方向代表不同法向量、不同明暗代表不同幅度的图像（这里我们选择性忽略了相位）。顺带提一句，磁共振也就是利用这个原理，先构建k空间中的信息，再利用逆向傅立叶变换，得到原本的医学影像的。 离散二维傅立叶变换的代码实现 根据上面的公式，我们就可以编写出如下的离散二维傅立叶变换的代码了，这里为了方便，选用了Python作为我们的编写语言，当然相应的，执行速度非常的慢，因此选择将图片resize到原来的0.05倍大小来查看： 12345678910111213def process_img(raw_img): width, height = raw_img.shape[:2][::-1] fimg = np.zeros(raw_img.shape, dtype=np.complex64) for v in range(height): for u in range(width): pixel = complex(0.0, 0.0) for y in range(height): for x in range(width): theta = -2.0j * np.pi * (u * x / width + v * y / height) pixel += np.exp(theta) * raw_img[y][x].astype(np.float64) fimg[v][u] = pixel print() return fimg 可以看到很简单地，几乎和公式保持完全一致地求和，这里的对频域图片的每个像素求值的时间复杂度达到了恐怖的\\(O(n^2)\\)，但是可以看到，效果还是非常不错的（原图片-自己编写的dft2-np提供的fft2）： 当然，这里最后的图像是将(u = 0, v = 0)移动到中心后得到的图像（np.fft.fftshift）。从得到的dft图像中我们得出这张肥猫小猫的图片的几个特征： - 在(0, 0)的地方振幅几乎为0，周围亮度高：超低频缺失，几乎不存在一成不变的区域，反之我们可以构造一副纯白的图片，其在(0, 0)点处应该为白色（下图需要放大才能看清那个白点） - 频域图像有黑色噪声分布：图像本身有不连续的噪声出现，是缩放导致的图片噪声，将图片放大后消失 图像频域分析的应用 说了这么多，频域上的分析到底有什么意义呢？平时我们很多直接分析图片发现不了的信息，都可以统统甩到频域上解决，或者是从频域的角度出发，对图片进行修改，比如我们已经知道了，高频信息往往出现在图片中的边缘区域（临近区域变化明显），这个时候，便可以通过过滤掉这些频率的信息（高斯模糊滤波）来实现；相反的，如果我们需要做边缘检测，便可以提取出频域上的高频区域来进行边缘的检测。 如何在一张图片中隐藏信息 在这方面其实有很多研究了，比较简单的有LBS（最低有效位），通过使用图片的每个像素最低bit来实现信息的嵌入，但是很明显，这种方法仅仅适用于无损图片，图片经过压缩或者变换之后很容易导致信息的缺失，这对于读准确率需求不高的情况是一个优秀的解决方案；对于需要高读准确率的场景，一方面会造成信息的浪费，另一方面在较高信息率的情况下，纠错正确率很难得到保证，这个时候，频域隐写技术就是一个很好的替代品。 频域变换技术通常使用的是不同于上文的DCT（离散余弦变换），DCT 变换的好处是，如果原序列是实数序列，那么变换后也是实数序列。[1]这里我们简单了解一下DCT隐写算法。 DCT隐写（两点法） DCT隐写算法直接针对JPEG图像进行（JPEG图像天然以8x8的子块存储），隐写算法的过程如下： 取出一个8x8的分块 通过DCT将分块变换到频域空间 随机（全局一致）选取两个点，并且根据需要嵌入的比特，通过像素值值赋予这两个点顺序（如果嵌入0则这两个点必须小的在前面，否则大的在前面，通过交换这两个像素来实现） 通过IDCT将块变换回去 这里需要注意的是，如果希望信息的抗干扰性高一些，我们需要在选取两个点的时候使其距离相对比较大。 提取的算法就很显而易见了： 对于每个8x8的分块做DCT 根据值大小，检查是否存在交换的现象，提取该分块的比特值 合并信息 总结 这一篇博客算是我写给自己的一个交代，之前一直无法理解一张图片是如何和信号、频域关联起来的，最近几天花了不少时间，查阅了大量的资料，总算是有了一个不算模糊的认知。 频域的分析也是实时和离线渲染中常常使用的工具，特别是实时渲染的后处理，经常通过频域搞事情，故希望自己在遇到这些东西之前，把图像频域方面的事情搞明白。 参考 Wikipedia-傅立叶变换 Wikipedia-离散傅立叶变换 百度百科-二维离散傅立叶变换 二维傅里叶变换是怎么进行的？ - 阿姆斯特朗的回答 - 知乎 如何理解傅立叶变换公式 - 苗华栋的回答 - 知乎 【隐写术】入门知识大全 A Secure Steganographic Algorithm Based on Frequency Domain for the Transmission of Hidden Information","link":"/2022/02/24/%E4%BF%A1%E5%8F%B7%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%A2%91%E5%9F%9F%E5%88%86%E6%9E%90/"},{"title":"剖析Rust中的str和String之间的区别与共性","text":"之前写代码的时候发现自己其实完全不懂String和str之间的区别，现在写篇文章来细 🔒 首先查看官方参考文档中对 String 的描述如下 The String type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive str. 我们可以发现 String 是拥有字符串内容的所有权的，而 str 则被描述为“借用”。查看具体实现的源代码，有如下的实现内容： 123pub struct String { vec: Vec&lt;u8&gt;,} 也就是说，String 是确确实实有“拥有”这个字符串内容的。而 str 在参考文档中被描述为如下的内容： Unicode string slices. See also the std::str primitive module. The &amp;str type is one of the two main string types, the other being String. Unlike its String counterpart, its contents are borrowed. string slices 意为字符串切片，那么说明一般 str 类型是作为指针，描述一个字符串切片的存在，而作为一个 primitive type，无法找到其具体内容实现，但是可以确定的是，它并没有对指向内容的所有权，但是由于往往作为引用 &amp;str 存在，因此有着更高的灵活性与便捷度。 关于字符常量 我们常常会使用类似于如下的代码创建 String 以及 &amp;str 变量： 12let a_string = String::from(&quot;驻留字符串&quot;);let a_str = &quot;这是字符串常量&quot;; 学习 Java 虚拟机时就学习过，虚拟机会将编译得到的字符串驻留(interned)，即，提前为不可变字符串在全局区域分配空间，如果有多个相同引用只需要实际创建一次即可。 我们可以看到，不论是上面的 a_string 还是下面的 a_str，都使用了相应的字符串常量，分别分配了两段内容为驻留字符串和这是字符串常量的文本于内存中，同时，String::from的实现为： 123456// String::fromimpl From&lt;Box&lt;str&gt;&gt; for String { fn from(s: Box&lt;str&gt;) -&gt; String { s.into_string() }} 继续追溯： 12345678910111213141516171819202122// str::into_stringpub fn into_string(self: Box&lt;str&gt;) -&gt; String { let slice = Box::&lt;[u8]&gt;::from(self); unsafe { String::from_utf8_unchecked(slice.into_vec()) }}// String::from_utf8_uncheckedpub unsafe fn from_utf8_unchecked(bytes: Vec&lt;u8&gt;) -&gt; String { String { vec: bytes }}// str::into_vecpub fn into_vec&lt;A: Allocator&gt;(self: Box&lt;Self, A&gt;) -&gt; Vec&lt;T, A&gt; { // N.B., see the `hack` module in this file for more details. hack::into_vec(self)}// hack::into_vecpub fn into_vec&lt;T, A: Allocator&gt;(b: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt; { unsafe { let len = b.len(); let (b, alloc) = Box::into_raw_with_allocator(b); Vec::from_raw_parts_in(b as *mut T, len, len, alloc) }} 我们发现，String::from其实是根据字符串常量内容自行 alloc 了相同的空间，并且将内容复制到该空间内（在堆空间内）。 总结 对于希望拥有字符串所有权，需要更大程度地掌控字符串，请使用 String 类型，而如果是作为一个不会更改的常量存在，则应该使用 str 类型进行操作。","link":"/2021/03/05/%E5%89%96%E6%9E%90Rust%E4%B8%AD%E7%9A%84str%E5%92%8CString%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%B1%E6%80%A7/"},{"title":"北邮大数据专业大三上课程总结","text":"首先指路BUPT 计科大三上生存指北 by xqmmcqs，感谢这篇文章给我大三上的课程复习带来了很大的帮助。 碎碎念：为什么会有这篇博客呢？因为我在网上找遍了资料，找到的博客或者复习指南基本都是北邮计科的，这对于小专业的学生来说太不友好了，因此萌生了写一篇和上面提到的文章一样的总结并且希望把这个作为一个习惯传下去（要是懒了就算了罢）。今天是2023年1月8日，正值最后一门成绩出完，因此在这里分享数据科学与大数据技术专业大三上的一些课程的主观感受。 操作系统 难度中上，需要背很多东西，基本是把操作系统的架构底朝天讲了个遍，遗憾或者说庆幸的是每一个内容的深度都不足。xz老师人还不错，今年期中由于封控政策延期了导致最后变成了全是大题，还想得起来的题型有线程调度、信号量之类的；期末则是常规的填空选择大题，复习的话推荐看一遍王道然后刷PPT（注意一些小的知识点，比如今年考了一个文件的访问方式我就写错了orz），大题题型最后都是很常规的PPT例题（今年PV题也不难），把PPT搞懂然后刷往年题就行。 课程附赠一个实验，不过不是单独算的，今年要求2-6人组队，由于已经给出了实验指导书并且书上有源码，本质cv。 数据库系统原理 难度中等，由于疫情提前放假削减了内容（其实不削减内容，课程容量也不大），并且期末改成了全部大题的形式，属于是一步错步步错。平时教授的内容对于实际数据库设计来说太过简单，并且也不太实用（3NF谁真用啊），不过确实是很基础的内容，不知道还是不行的。df老师课讲得不错，并且ppt也写的很详细，因此期末同样是刷ppt做例题就好，重点是ER图、范式、关系的设计几个内容。需要注意的是今年SQL题偏应用，竟然考到了多表的删除操作……因此自己适量课外拓展一些SQL的学习还是很有必要的。 虽然同样是用GaussDB，好在今年的实验不像往年一样坑人出现各种奇怪的问题，不过依然推荐等ddl之前，其他人把坑踩差不多了再上。 大数据技术基础 难度简单，ozh唯一指定课程，从开学一直到结束上课就没听过（逃），最后复习的时候读了下课程内容，主要是教你一些2010-2020年左右流行的框架和特点，作为一门新兴课程教授的内容却不是非常前沿。好在虽然ozh老师比较唠叨并且成吨的ppt看着也很唬人，但是最后期末会给划重点（平时扫码答题仅作签到用）导致难度直线下降。值得注意的是虽然数据分析层和数据可视化层最后划重点没划进去，但是期末还是作为综合设计题的一部分考到了（大概是给你一个场景，让你选择大数据6层架构中每一层合适的开源组件进行处理）。因此如果确定前面的重点复习完了，这不在重点内的两层还是有必要复习一下的。 课程设计没什么好说的，按照实验指导书cv就行，需要注意的是每一次上课都必须去（因为当堂验收）。以及课设单独算1.5（好像）个学分。 Linux开发环境及应用（选修但是很推荐） 难度中等偏下，jyj老师教授，上课貌似没有考勤，并且会叫同学们去mooc上学习他的课、完成作业和测试来作为平时成绩。非常有用的好课，上课会教授Linux各种命令的组合使用、Unix下的程序设计之类的实用内容，类似于计算机教育中缺失的一课，并且给分也十分大气（90+）。期末作业从平时作业的题库中抽题，不过还是会有很多新题，需要好好复习课件。 基于大数据的机器学习 非常呃呃的课程，难度因为没怎么上课，期末也没考明白所以不评价，zwa老师教授。平时上课主要讲一些机器学习算法的推导和原理（数据科学导论：？？？），老师可能比较科研型，不是很听得懂在讲什么，了解相关内容不如自己看西瓜书。成绩主要是平时成绩+期中（我因为疫情没有参加）+期末考试（全选择）+期末大作业构成，其中期末成绩由期末考试和期末大作业对半分。这个课程的诡异之处在于平时作业/上课内容和期末考试完全没有任何关系，并且往年也没有任何期末题漏出，导致期末考试的风格极其神秘：虽然平时会花80%+的时间讲各种学习器的推导，期末大部分的考点却是集中在各种机器学习的概念上。不过可能是去年被喷了，今年评分规则也收敛了些，把大作业的占比提高到了50%。大作业的话是CNN的图片分类，今年我用的resnet50然后加一些超参就能达到不错的准确率（90%+）。 总结 本学期课程同样是不压分，平均分可以给到很高，除了机器学习这门课以外别的课基本都是上课好好听+认真复习就能拿高分的。不过单论价值性的话除了Linux以外都不是很高，因此建议在压力不是很大的时候可以课外多学点东西（但是课内的东西一定要掌握好，这俩不是可以覆盖的关系）。 关于复习资料的话可能之后会发个网盘……吧？","link":"/2023/01/08/%E5%8C%97%E9%82%AE%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%93%E4%B8%9A%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"实时渲染：使用OpenGL进行蒙特卡洛路径追踪","text":"先上个成果图： 使用OpenGL和GLSL实现了一个基于物理的蒙特卡洛路径追踪，接下来简述一下实现的原理和思路。仓库地址：RealtimeRayTracing OpenGL端 在OpenGL端，采用了简单的ping-pong texture和一个final shading来实现了逐帧增加spp数量的效果： 这一段的核心代码大致如下： 1234567891011121314151617181920212223// 绘制pathtracer framebufferif (m_cam_move_flag) { glClear(GL_COLOR_BUFFER_BIT); glClearColor(GL_RGBA_BLACK); m_cam_move_flag = false;}m_rtrt_shader.use();m_rtrt_shader.setTexture(&quot;uLastFrame&quot;, 0, m_screen_texture[pingpong]);m_rtrt_shader.setUniform(&quot;uPingpong&quot;, pingpong ^ 1);m_rtrt_shader.setUniform(&quot;uRand3&quot;, randomVec3());m_spp += m_light_samples;m_quad.draw();// 绘制screen framebufferm_fbo.unbind();m_final_shader.use();m_final_shader.setTexture(&quot;uRenderTexture&quot;, 0, m_screen_texture[pingpong ^ 1]);m_final_shader.setUniform(&quot;uSPP&quot;, std::max(1, (int)m_spp));m_quad.draw();pingpong = pingpong ^ 1; 需要注意的是，这里应该是必须要使用pingpong texture交替渲染才能实现，因为同时读写一个texture是未经过定义的行为。 总的来说，由于我暂时还没有实现渲染CPU端读入的模型，在OpenGL端并没有什么实现难度。 Shader实现 顶点着色器 在顶点着色器中，需要做两件事： 计算出四个顶点的光线的origin和dir，在fragment shader中插值使用。 根据摄像机uv向量和framebuffer大小计算出每个像素的随机采样范围。 这里就需要搞清楚几个概念：Camera, Film, Framebuffer，首先，我们是通过摄像机发射光线，形成透视的光线到世界中进行采样，那么应该从什么方向去发射光线呢？类似于摄影的原理，我们使用一张“胶片”来保存所有的信息，也就是所谓的Film，我们规定好摄像机光线起点的位置作为origin，在摄像机正前方放上一张胶片，对于胶片上的每个点发射光线即可，而后将胶片上的各个光线着色点映射到Framebuffer的每个像素上，这样就可以很清楚明白地解释成像的原理了！ 首先定义摄像机的几个重要属性： 1234567struct Camera { vec3 position; float fov; float aspectRatio; vec3 front; vec3 up;}; 这里的up并不一定是垂直于front方向的，我们只需要利用这个向量来计算一个摄像机的uvw坐标系（这里的w和摄像机的front方向是相反的）： 123vec3 w = normalize(-uCamera.front);vec3 u = normalize(cross(uCamera.up, w));vec3 v = cross(w, u); 接下来，我们假设摄像机到胶片的距离为1.0，则可以根据fov和aspect ratio来计算出胶片的大小： 1234567vec2 calcViewportSize() { // distance == 1.0 float h = tan(uCamera.fov / 2.0); float height = 2.0 * h; float width = uCamera.aspectRatio * height; return vec2(width, height);} 根据uvw构成的坐标系，可以计算出胶片的lowerLeft坐标，再将lowerLeft坐标加上根据纹理坐标得到的胶片像素偏移（因为OpenGL里传入的模型为一个屏幕quad），即可得到每个胶片像素的位置： 12345vec3 lowerLeft = uCamera.position - 0.5 * u * filmSize.x - 0.5 * v * filmSize.y - w;rayOrigin = uCamera.position;rayDir = lowerLeft + u * aTexCoord.x * filmSize.x + v * aTexCoord.y * filmSize.y - rayOrigin; 因为我们希望在之后的片段着色器中实现多次采样的时候能够实现在像素中随机地采样光线，我们还需要将u、v方向的变化范围传入fragment shader。已知的是，OpenGL对于每个像素着色时，实际着色的坐标为(x + 0.5, y + 0.5)，我们希望在生成[-1, 1]的随机数的时候，光线在(x, y) - (x + 1.0, y + 1.0)的范围中随机采样，于是我们的range范围便应该是\\(frac{uv * 0.5 * filmeSize}{framebufferSize}\\)： 12345// flat表示输出到fragment shader中不需要进行插值flat out vec3 vHorizontalRange;flat out vec3 vVerticalRange;vHorizontalRange = u * 0.5 * filmSize.x / uFramebufferSize.x;vVerticalRange = v * 0.5 * filmSize.y / uFramebufferSize.y; 片段着色器 首先这里要讲解一下蒙特卡洛路径追踪的几大特征： 直接空间中根据几何信息进行求交（和RayMarching的步进策略不同），得到的是准确的几何解。 使用SPP从摄像机发射大量光线，代替从反射点大量发射光线，来实现蒙特卡洛采样。 递归追踪光线，直到俄罗斯轮盘赌判定为结束/没有击中任何物体/达到最大反射次数时结束（这里需要提及的是，如果按照正确的渲染方程，在击中有\\(L_e\\)自发光的物体的情况下仍然需要进行采样和追踪，但是我们为了简化追踪流程，在光线击中了灯光后不会继续反射，而是直接结束弹射） 首先祭出祖师爷渲染方程： \\[L_o = L_e + \\int_\\Omega f_r\\cdot L_i\\cdot(\\omega_i\\cdot \\vec{n})\\text{d}\\omega_i\\] 其中\\(f_r\\)项就是大名鼎鼎的BRDF函数了，这个函数接受入射方向、反射方向、法线方向以及材质信息，计算光线经过这一次弹射的能量变换（颜色的出现本质上也是不同材料对于不同波长光的吸收比率不同而有所不同，因此颜色的不同本质上也是brdf的不同），但是我们这里为了偷懒简化模型，和ray tracing in one weekend中一样，认为\\(brdf = color\\)，即，认为采样的每一条反射/折射光线都只被吸收了vec3(1.0) - vec3(color)的能量，虽然并不是完全的物理正确，但是对于一个简单的路径追踪也是够用的。 剩下的就很简单了，这里引用一张GAMES101的图片来说明整个路径追踪流程： 即，我们需要递归地对光线打到的每个点进行着色，然后对结果进行累乘，得到的即是最终的结果。 但是，问题就来了：路径追踪的核心显而易见：递归，glsl中并不支持递归（甚至不是不支持，而是glsl的内存模型禁止递归，这很好理解，GPU的显存+并行化的模式不允许有过深的函数栈存在）。那么怎样才能实现这样的递归方法呢？我们观察路径追踪的流程，发现其实整个过程中并不需要有辅助栈的存在——即使实现为递归，由于每一次递归调用均在函数末尾，因此编译器也会进行尾递归优化。我们只需要使用两个辅助变量：color和brightness即可使用循环替代整个递归流程，伪代码如下： eval1234567891011121314151617181920vec3 brightness = vec3(1.0), color = vec3(0.0);float p_RR = 0.8;Intersection inter;for(int i = 0; i &lt; MAX_BOUNCE; i++){ if (random() &gt; p_RR) break; if(hasIntersection(ori, dir, inter)){ if(inter.isLight){ color = inter.color * brightness; }else{ vec3 new_dir = randomSample(pdf); float cosine = dot(inter.normal, new_dir); brightness = brightness * inter.color * cosine / pdf / p_RR; ori = inter.position; dir = new_dir; } }else{ break; }}return color; glsl的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758vec3 recursivePathTracing(vec3 origin, vec3 dir) { vec3 rayColor = vec3(0.0); vec3 rayBrightness = vec3(1.0); float p_RR = 0.8; for (int i = 0; i &lt; uLightBounceCount; i++) { if (random(randSeed.xy) &gt; p_RR) break; Intersection inter; if (!hasIntersect(origin, dir, inter)) { break; } Material material = inter.material; if (material.isLight) { rayColor = material.color * rayBrightness; break; } else { float cosine = 1.0; float pdf = 1.0; // add a slight offset from hit position to prevent artifacts // https://computergraphics.stackexchange.com/questions/7789/weird-artifacts-in-my-ray-tracer origin = inter.position + inter.normal * EPS; vec3 rs = normalize(random3(randSeed)); if (material.type == DIFFUSE) { dir = normalize(randomHemispherePoint(rs, inter.normal)); pdf = 2.0 * PI; cosine = dot(dir, inter.normal); } else if (material.type == METALIC) { dir = reflect(dir, inter.normal); cosine = dot(dir, inter.normal); } else if (material.type == GLASS) { float si = dot(dir, inter.normal); float eta = 0.66; if (si &lt; 0.0) { float rd = random(randSeed.xy) + 1.0; rd /= 2.0; // incident if (rd &lt;= fresnelApprox(normalize(dot(-dir, inter.normal)), 1.0, 1 / eta)) { dir = reflect(dir, inter.normal); cosine = dot(dir, inter.normal); } else { dir = refract(dir, inter.normal, eta); origin = inter.position - inter.normal * EPS; cosine = dot(dir, -inter.normal); } } else { // exitent dir = refract(dir, -inter.normal, 1 / eta); cosine = abs(dot(dir, inter.normal)); } } cosine = max(cosine, 0.0); rayBrightness *= material.color * cosine / p_RR / pdf; randSeed = rs; } } return rayColor;} 这里需要注意的是为了防止光线在打到物体表面后，由于float精度问题，弹射光线有可能被物体自己拦截而产生artifact。使用沿法线方向位移一小段距离的方式来防止自遮挡的问题。 小结 目前的路径追踪器虽然已经能运行出较为不错的效果了，但是离一个真正的路径追踪渲染器还差不少，接下来会继续添加如下的功能： 基于三角形的模型 低spp下对光源进行采样以优化效果 物理正确的brdf模型 PS：当初我入门图形学的第一个项目就是跟着raytracing in one weekend做的，现在回忆起来，当时做的是一知半解，连做个并行化都很费劲，但是现在自己可以独立地手写一个路径追踪器了，颇为感慨。 Update 2022-4-4 今天在为追踪器实现cosine-weight采样的时候发现了实现中的几个问题，这里需要提及一下： BRDF &amp; PDF &amp; cosine 已知渲染方程是上面的形式，cosine项肯定是去不掉的，但是在之前的实现里，pdf和brdf的实现其实是有误的：pdf作为采样的概率密度函数，代表的应该是每个采样射线出现的概率，对于一个均匀半球采样，其值应该是\\(1.0 / 2\\pi\\)，之前误写为了\\(2\\pi\\)，但是如果直接更改会发现出现了颜色的过亮，这正是因为BRDF也不正确，diffuse材质下，Lambertian brdf模型规定brdf应该为\\(\\frac{\\sigma}{\\pi}\\)——正好抵消了这个多出来一倍的\\(\\pi\\)（虽然这么理解肯定是不正确的）。 随机采样函数 随机采样函数接收的种子是\\((x, y, z) \\in[-1, 1]\\)，而且xyz三个分量应该都是独立均匀分布的，之前粗心直接用了一个normalize导致得到的范围是有问题的！ To be continued...","link":"/2022/04/03/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%EF%BC%9A%E4%BD%BF%E7%94%A8OpenGL%E8%BF%9B%E8%A1%8C%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"title":"实时渲染：屏幕空间反射SSR","text":"从上次面试之后，就寻思着用Unity做一些实时的渲染效果，这个时候就想起了GAMES202作业中的实时屏幕空间反射。 屏幕空间反射效果可以产生微妙的反射，模拟潮湿的地板表面或水坑。这种技术产生的反射质量低于使用反射探针或平面反射（后者可以产生完美平滑的反射）。屏幕空间反射是用于限制镜面反射光泄漏量的理想效果。 屏幕空间反射的本质是利用GBuffer中的Normal, Albedo, Depth几个分量进行屏幕空间（以及view space）的RayMarching，简单的做法是，从摄像机发射一条光线到每个Shader fragment，再根据fragment的法线计算出reflect方向，这样就相当于得到了一条ray的origin和dir。这个时候我们再将步进的射线的z深度与depth texture的值进行比较，即可得到是否intersect，进而进行反射颜色的计算。 实现 首先给Unity的摄像机加上一个material和shader，用类似于opengl的blit方法将渲染目标更改为一个texture传输给shader，这里因为Unity好像没有提供WorldToView矩阵，我们需要自己传给Shader，同时由于需要使用GBuffer中的信息，需要将渲染模式改为deferred（其实也不是必须的，但是使用前向渲染模式需要自己手动额外渲染所需的信息，会造成资源的浪费）。 1234567891011121314151617181920212223242526272829public class CamToTexture : MonoBehaviour{ private Material mat; public Shader shader; public bool useSSR = true; // Start is called before the first frame update void Start() { GetComponent&lt;Camera&gt;().depthTextureMode = DepthTextureMode.Depth; } public Material material { get { mat = CheckShaderAndCreateMaterial(shader, mat); return mat; } } private void OnRenderImage(RenderTexture src, RenderTexture dest) { if (useSSR) Graphics.Blit(src, dest, material); else Graphics.Blit(src, dest); Shader.SetGlobalMatrix(&quot;_NormalWorldToView&quot;, GetComponent&lt;Camera&gt;().worldToCameraMatrix.inverse.transpose); }} 在顶点着色器中，首先通过uv坐标计算出裁剪坐标，z坐标设置为远裁剪平面的位置\\(1\\)，再用投影逆变换把每个fragment的view space坐标计算出来（\\(P^{-1} \\cdot P \\cdot V \\cdot M \\cdot \\vec{p}\\)），然后同样进行透视除法（逆矩阵同样会对\\(w\\)分量造成影响，很好理解） 12345// uv -&gt; clip spacefloat4 origin = float4(v.uv * 2 - 1, 1, 1);// clip space -&gt; view spaceorigin = mul(unity_CameraInvProjection, origin);o.rayOrigin = origin / origin.w; 接下来，在片段着色器中得到已经插值的rayOrigin。众所周知透视投影得到的深度是非线性的，因此需要一个Linear01Depth的线性转换。同时把远裁剪平面的z1转换到对应的深度中。 123456789101112131415float depth = Linear01Depth(tex2D(_CameraDepthTexture, i.uv).r);// view space ray originfloat3 rayOrigin = depth * i.rayOrigin;float3 worldSpaceNormal = tex2D(_CameraGBufferTexture2, i.uv).rgb * 2 - 1;float3 viewSpaceNormal = normalize(mul((float3x3)(_NormalWorldToView), worldSpaceNormal));float4 color = tex2D(_MainTex, i.uv);// raymarching hit uv positionfloat2 hituv;float4 reflectColor = float4(0, 0, 0, 0);if(rayMarch(rayOrigin, normalize(reflect(rayOrigin, viewSpaceNormal)), hituv)){ reflectColor = _RefInt * tex2D(_MainTex, hituv);}return color + tex2D(_CameraGBufferTexture1, i.uv) * reflectColor; 接下来就是屏幕空间的RayMarching，在每个步骤中求得对应的光线深度pDepth（因为从view space来到了clip space，需要除以远裁剪平面的z值），随后很简单地将view space的ray乘上投影矩阵，得到平面空间坐标（之后转换到uv坐标需要除以2加0.5）。这里intersect的算法很简单地使用了rayDepth &gt; objDepth，也就是物体比光线更远的时候视为一次命中。 1234567891011121314151617181920212223bool rayMarch(in float3 rayOrigin, in float3 rayDir, out float2 hit){ hit = float2(0, 0); float3 ray = rayOrigin; UNITY_LOOP for(int i = 0; i &lt;= MARCH_STEPS; i++){ ray += STEP_SIZE * rayDir; // ray depth, divide far clip space plane float rayDepth = ray.z / -_ProjectionParams.z; float4 screenSpaceCoord = mul(unity_CameraProjection, float4(ray, 1)); // projection division screenSpaceCoord /= screenSpaceCoord.w; if(screenSpaceCoord.x &lt; -1 || screenSpaceCoord.x &gt; 1 || screenSpaceCoord.y &lt; -1 || screenSpaceCoord.y &gt; 1){ // outside screen space return false; } float objDepth = Linear01Depth(tex2Dlod(_CameraDepthTexture, float4(screenSpaceCoord.xy / 2 + 0.5, 0, 0))); if(rayDepth &gt; objDepth){ hit = screenSpaceCoord.xy / 2 + 0.5; return true; } } return false;} 优化 To be continue... Reference 在Unity中实现屏幕空间反射Screen Space Reflection 图形学基础|屏幕空间反射(SSR)","link":"/2022/03/16/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%8D%E5%B0%84SSR/"},{"title":"最大流算法","text":"最近学离散发现网上对于最大流算法介绍的比较少，因此写个 blog 记录一下相关的知识点 最大流 定义一个有向图中的两个顶点分别为源点和汇点，源点入度为 0，汇点出度为 0，每条边有属性最大流量(maximum capacity)，表示该边能通过的流量的最大值。我们称该有向图从源点到汇点的最大的流量值即为该图的最大流。 对于如上图的一张图，想要获得从源点 1 到汇点 6 的最大流，我们可以使用如下的朴素算法： 打标签算法(LABELING ALGORITHM) 算法出处：《离散数学结构》P299 算法的思想：将所有边都视为一条实边和一条虚边，其中实边代表我们图中已经给出的方向，而虚边则代表与图中已有方向相反的一条“虚构”的边 (作用在算法中会具体说明)，实边和虚边的流量和一定 (一条路的最大流量是不变的)。 步骤：通过类似于 广度优先搜索 的方法 ，每一次确定一条从源点到汇点的最大流，并且每次通过回溯将所有途经过的实边减去这条最大流量，相应的虚边加上最大流量，直到无法再找到一条最后能通过实边抵达汇点的最大流，算法停止。 具体步骤 定义一个集合 \\(N\\) ，其中用于记录当前已经加入的点的集合，最开始将源点 1 加入 \\(N\\)。 将最新加入的元素进行延拓至所有可抵达的，且不属于\\(N\\)中的元素 (先后顺序参照序号) ，对于有向边\\(e_{ij}\\)，如果\\(e_{ij}\\gt0\\)，则路径可通 (如果方向和图中路径相反，则考虑虚边是否大于零)，第一次则将 1 延拓至 2 4，并且将其分别标记上\\([5,1] [4,1]\\) (格式为[可以进入的最大流量, 从哪一个点延拓至该点]) 将新加入的点加入到 \\(N\\) 中 回到步骤 2，直到 (假设汇点序号为 6) \\(6\\in N\\)，记录此时最大的流量 \\(f\\) 回溯延拓至汇点的路径，将其对应的实边 \\(e_{ij}=e_{ij}-f\\)，虚边\\(e_{ji}=e_{ij}+f\\) 回到步骤 1 ，直到无法有路径延拓至汇点","link":"/2020/12/16/%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95/"},{"title":"杂谈：进行全麻手术是怎样一种体验？","text":"年前因为某些原因需要进行颈部的全麻手术，也是我人生中第一次进行全麻手术。我一直都是对于现代医学持敬畏的态度，对于全麻的体验是非常期待的（又有哪一个程序员能拒绝一次立即入眠的体验呢？） 术前 手术需要提前大概3、4天住院，主要目的是进行相关的各种术前检查，大概就是在病房里护士来给你抽血啥的。看了一眼医生开的单子，我需要做的手术是吸入式的麻醉，于是进行了一个挺有意思的麻药测试，麻醉医生会把麻药滴在鼻腔和喉咙处，然后伸进去一个管子查看鼻腔的通气情况，有趣的是在滴入了麻药之后，我似乎无法作出吞咽这个动作，可能是喉咙处的神经被麻痹了而无法很好地被大脑控制的缘故。 术前检查做的差不多了，医生提前一天拿着好几张单子来找我签字，上面的内容都十分的吓人（PS：感觉到医院里签的各种承诺书、知情书内容都相当可怕），包括但不仅限于：术中、术后发生的各种意外情况，但是这单子不签这几天院就白住了，签呗，相信医学。遂被医生告知星期一早上8点半手术，我估计在第一床或者第二床的排班上，还给了一套衣服叫提前穿上。 手术 早上8点被护士准时叫去做手术了，必须穿医院的病号服（内衣内裤都必须完全脱掉），还行，到了手术室前有一扇像ct室的很厚的金属门，门外就是家属等待的地方，接着就是换医院的拖鞋，进手术室。这个医院的手术室分为很多小的手术室，和我想象中的那种拉着窗帘、比较暖和的手术室不同，大概就是一个普通的病房开了比较合适的空调。到了位置，医生叫我把衣服脱了躺手术台上，这个手术台和我印象中的宽宽大大的手术台截然不同，长度和理发店的那种洗发躺椅差不多，而且非常窄，躺上去了完全无法翻身，接着医生用一根带子把我绑好在手术台上（让我安心许多），然后把左手伸出去，在手背和胳膊的位置分别扎了两针，同时注射两种液体（后来得知是麻醉的时候需要的）。 接下来就是麻醉了，麻醉医生穿着的是紫色的手术大褂，问了我一些简单的问题，比如多少岁，在哪读书啊之类的，扎完针后我心里想着麻醉也应该开始了，果然，推着一台机器过来了，给我脸上盖上一个呼吸面罩（还盖歪了），麻醉医生来了一句：想睡觉就睡吧，我心想着这么快吗，于是也使劲地吸面罩里的气体，好在是医生发现给我戴正了。然后接下来几句话就是我后面仅有的记忆了： xxx推0.5 xxx推0.7 ... 真的太神奇了，自己都感觉不到入睡的过程，只记得麻醉之前的事情，在某个瞬间，一下子就失去了意识，中途也没有做梦什么的，总之是很顺利地进行了手术。 术后 手术之后的事情可以说是整个过程中最最最最痛苦的了……让我这辈子都不再想再做手术了，包括但不仅限于： 尿管 术后两小时不能睡觉 术后六小时不能喝水不能进食 术后一晚上几乎是睡不着的 术后两天需要持续输液 具体感受不是重点，不再赘述了。 一些感想 正如前文所说，我对现代医学是十分尊重的态度，在进行了人生第一场手术后，对它的神奇和严谨更是敬佩有加，我只是一个被推上手术台，在手术过程中毫无知觉的患者，但是医生需要高度集中精神，根据术前检查和术中的观察，在有限的几个小时中完成手术，而且中途还不能查阅Google（笑），相较而言，程序员的工作可以说是非常宽限的了。 术业有专攻，向奋战在现代医学一线的人们致以崇高的敬意。","link":"/2022/02/04/%E6%9D%82%E8%B0%88%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%85%A8%E9%BA%BB%E6%89%8B%E6%9C%AF%E6%98%AF%E6%80%8E%E6%A0%B7%E4%B8%80%E7%A7%8D%E4%BD%93%E9%AA%8C%EF%BC%9F/"},{"title":"概率论与数理统计期末复习","text":"期末之前临时抱佛脚，复习数理统计 数理统计部分 统计量 样本平均值 \\[\\bar{X}=\\frac{1}{n}\\sum_{i=1}^nX_i\\] 样本方差 \\[S^2 = \\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\bar{X})^2\\] 样本标准差 \\[S = \\sqrt{S^2}\\] 样本 k 阶（原点）矩 \\[A_k=\\frac{1}{n}\\sum_{i=1}^nX^k_i,\\quad k=1,2,...;\\] 样本 k 阶中心矩 \\[B_k=\\frac{1}{n}\\sum_{i=1}^n(X_i-\\bar{X})^k,\\quad k=1,2,...;\\] 重要定理 Levy-Lindberg 定理 对于已知期望\\(E(X_k) = \\mu\\)、方差\\(D(X_k)=\\sigma^2\\)的独立同分布随机变量，有样本均值 \\[\\bar{X}\\sim N(\\mu, \\sigma^2/n)\\] Liapunov 中心极限定理 对于已知期望\\(E(X_k) = \\mu_k\\)、方差\\(D(X_k)=\\sigma^2_k\\)的独立非同分布随机变量，有样本之和 \\[\\sum_{k=1}^nX_k\\sim N(\\sum_{k=1}^n\\mu_k, \\sum_{k=1}^n\\sigma_k^2)\\] 上面两个定理，我们可以将其用于对于之后的样本估计，其核心思想是将未知分布的随机变量的样本当做正态分布来处理。 重要分布 名称 定义 性质 数学期望和方差 对称性 \\(\\chi^2\\)分布 \\[\\chi^2=\\sum_{i=1}^nX_i^2, \\quad X_i\\sim N(0,1)\\] \\[\\chi^2_1+\\chi^2_2\\sim\\chi^2(n_1+n_2)\\] \\[E(\\chi^2)=n,\\quad D(\\chi^2)=2n\\] 非对称 \\(t\\)分布 \\[t=\\frac{X}{\\sqrt{Y/n}}, \\quad X\\sim N(0,1),Y\\sim \\chi^2(n)\\] 上下分位点对称 无 对称 \\(F\\)分布 \\[F=\\frac{U/n_1}{V/n_2}, \\quad U\\sim\\chi^2(n_1),V\\sim\\chi^2(n_2)\\] \\[\\frac{1}{F}\\sim F(n_2,n_1)\\] \\[F_{1-\\alpha}(n_1,n_2) = \\frac{1}{F_\\alpha(n_2,n_1)}\\] 无 非对称 样本的性质 四大定理 对于来自正态总体的样本\\(X_i\\)，其样本均值、方差分别为\\(\\bar{X}\\)、\\(S^2\\)，总体的均值为\\(\\mu\\)、\\(\\sigma^2\\) 样本均值的分布 \\[\\bar{X}\\sim N(\\mu,\\sigma^2/n)\\] 样本方差的分布 \\(\\frac{(n-1)S^2}{\\sigma^2}\\sim \\chi^2(n-1)\\) \\(\\bar{X}\\)、\\(S^2\\) 相互独立 样本均值、标准差组成的分布 \\[\\frac{\\bar{X}-\\mu}{S/\\sqrt{n}}\\sim t(n-1)\\] 来自正态的独立样本相关分布 前置条件，已知有如下的定理成立 \\[\\bar{X}-\\bar{Y}\\sim (\\mu_1-\\mu_2, \\frac{\\sigma^2_1}{n_1}+\\frac{\\sigma^2_2}{n_2})\\] \\(\\frac{S^2_1/S^2_2}{\\sigma^2_1/\\sigma^2_2}\\sim F(n_1-1,n_2-1)\\) 若有\\(\\sigma^2_1=\\sigma^2_2=\\sigma^2\\) （整体方差相等） \\[\\frac{(\\bar{X}-\\bar{Y})-(\\mu_1-\\mu_2)}{S_w\\sqrt{1/n_1+1/n_2}}\\sim t(n_1+n_2-2)\\] \\[S_w^2=\\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}, \\quad S_w=\\sqrt{S^2_w}\\] 参数估计 对于已知分布函数的总体\\(X\\)的部分参数的估计。 点估计 估计值：使用\\(x_1,x_2,x_3,...,x_n\\)表示的参数值 估计量：使用\\(X_1,X_2,X_3,...,X_n\\)表示的参数值 矩估计法 使用样本原点矩对总体参数进行估计，即，使用\\(A_i\\)来替代\\(E(X^i)\\)，代入等式得到参数的估计值。 极大似然估计法 对于分布律形如\\(P\\{X=x\\}=p(x;\\theta)\\)的离散型随机变量或者概率密度函数形如\\(f(x;\\theta)\\)，令 则有\\(\\hat{\\theta}=argmax L(x_1,x_2,...,x_n,\\theta)\\) 点估计的无偏性 对于一个参数\\(\\theta\\)的估计量\\(\\hat{\\theta}\\)，当且仅当\\(E(\\hat{\\theta})=\\theta\\)时，有\\(\\hat{\\theta}\\)为\\(\\theta\\)的无偏估计。 区间估计 对于分布函数为\\(F(x;\\theta)\\)的随机变量总体\\(X\\)，若存在 ​ \\[P\\{\\underline{\\theta}(X_1,X_2,...,X_n)&lt;\\theta&lt;\\bar{\\theta}(X_1,X_2,...,X_n)\\}\\ge1-\\alpha\\] 则称 \\(\\underline \\theta\\) 和 \\(\\bar \\theta\\) 为 \\(\\theta\\) 的置信水平为 \\(1-\\alpha\\) 的置信下限和置信上限。 题目做法 首先找到参数的一个无偏估计，然后运用此无偏估计和参数构造枢轴量（不依赖于未知参数的服从已知分布的随机变量），使用该枢轴量得到对应的未知参数的置信区间（参考 P161 例 1）。 单个正态总体的估计 正态总体 \\(X\\sim N(\\mu,\\sigma^2)\\)，置信水平\\(1-\\alpha\\) \\(\\mu\\)的置信区间 \\(\\sigma\\)已知 置信区间为 \\((\\bar{X}\\pm \\frac{\\sigma}{\\sqrt{n}}z_{\\alpha/2})\\) （\\(z_{\\alpha/2}\\)为标准正态的上\\(\\alpha/2\\)分位点） \\(\\sigma\\)未知 置信区间为\\((\\bar X \\pm \\frac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1))\\) \\(\\sigma^2\\)的置信区间 \\[(\\frac{\\sqrt{n-1}S}{\\sqrt{\\chi^2_{\\alpha/2}(n-1)}},\\frac{\\sqrt{n-1}S}{\\sqrt{\\chi^2_{1-\\alpha/2}(n-1)}})\\] 两个正态总体 正态总体 \\(X_i\\sim N(\\mu_i,\\sigma_i^2)\\)，置信水平\\(1-\\alpha\\) \\(\\mu_1-\\mu_2\\)的置信区间 \\[(\\bar{X_1}-\\bar{X_2}\\pm t_{\\alpha/2}(n_1+n_2-2)S_w\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}})\\] 其中\\(S_w\\)的定义和前文相同。 \\(\\sigma_1^2/\\sigma_2^2\\)的置信区间 \\[(\\frac{S_1^2}{S_2^2}\\frac{1}{F_{\\alpha/2}(n_1-1,n_2-1)},\\frac{S_1^2}{S_2^2}\\frac{1}{F_{1-\\alpha/2}(n_1-1,n_2-1)})\\] 假设检验 P189，表 8-1","link":"/2020/12/24/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"正交投影&amp;透视投影","text":"Let's do some math. 由于我们在计算机中的三维图像最终都是需要渲染到屏幕上的，所以我们需要对其进行一次投影的操作，首先假定我们的坐标为右手系，我们首先在\\((0,0,0)\\) 原点坐标处放置朝向\\(-z\\)方向，上方为\\(y\\)轴方向的摄像机，需要得到的图像的大小为 1x1(假设下的理想情况)。现在，有两种投影方式可供选择： 正交投影 Orthographic Projection 虽然这并不是我们最终希望使用的投影方式，但是正交投影在许多场景如 2D 游戏、工程制图等都得到了较为广泛的应用。 上图为一个典型的正交投影，我们将一个图像等比例地以平行线投射到我们的摄像机采集面（即最终屏幕显示）上，我们并不希望 挪动我们的坐标系或者摄像机，因为这样会导致其他物体的相对摄像机位置改变，于是我们采用将物体“挪动”到原点的方式来产生 最终的图像。于是总共需要进行两次变换：将物体挪动至原点，按 1x1 的目标画布大小进行放缩。 我们假设这个物体为一个正方体(其实所有的物体都可以抽象地看作一个个小立方体)，其前、后、上、下、左、右六个面距离立方体中心的距离为\\(n, f, t, b, l, r\\)(由于摄像机看向\\(-z\\)方向，这里规定\\(n\\gt f\\)根据前面的齐次坐标变换公式，可以得到如下的变换矩阵： \\[ M_{ortho} = \\left[\\begin{matrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix}\\right] \\left[\\begin{matrix} 1 &amp; 0 &amp; 0 &amp; -\\frac{l+r}{r - l}\\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{t - b}\\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{n - f}\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix}\\right] =\\left[\\begin{matrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{l+r}{r - l}\\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t - b}\\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; -\\frac{n+f}{n - f}\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix}\\right] \\] 透视投影 Perspective Projection 被广泛应用的投影，原因是其成像与实际生活中得到的成像更为相似，有“近大远小”、“平行相交”的特性。 那么，如何得到一副透视投影？我们可以类比正交投影，发现：可以先将投影的三维梯形底面进行放缩至与目标投影面同样的大小， 再进行一次正交投影，则可以得到目标透视投影， 那么如何得到预处理矩阵\\(M_{persp\\rightarrow ortho}\\)？根据上图，可以发现这是一个相似三角形，\\(y_s:y = d:z\\)，于是有目标点为\\((dx/z, dy/z, ?, 1)\\)， 将其乘上\\(z\\)得到\\((dx, dy, ?, z)\\)，但是根据这些我们并不能知道原来的\\(z\\)变成了什么(因为放缩之后一方面\\(z\\)会发生变化，另一方面 \\(z\\)的目标位置并不是\\(d\\)(需要保持原有的先后顺序)，于是我们便需要求出这个未知的值。 可以根据以下两条性质求出未知值： 在近平面的点\\(z\\)坐标不会改变 在远平面的点\\(z\\)坐标也不会改变 于是我们可以得到如下的转换矩阵 \\[ M_{persp\\rightarrow ortho} = \\left[\\begin{matrix} n &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; n &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; n+f &amp; -nf\\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{matrix}\\right] \\] 再将两个矩阵乘在一起，我们可以得到最终的变换矩阵 \\[ M_{persp} = M_{ortho}M_{persp\\rightarrow ortho} = \\left[\\begin{matrix} \\frac{2n}{r-l} &amp; 0 &amp; \\frac{l+r}{l-r} &amp; 0\\\\ 0 &amp; \\frac{2n}{t-b} &amp; \\frac{b+t}{b-t} &amp; 0\\\\ 0 &amp; 0 &amp; \\frac{f+n}{n-f} &amp; \\frac{2fn}{f-n}\\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{matrix}\\right] \\] fov &amp; aspect ratio fov，全名 Field-of-View，代表眼睛的可视角度，在图形学里我们使用 fov 来代替直接使用 width x height 的表示方式，比如用\\(fovY\\)来表示 Y 轴方向的可视角度，这个时候我们可以通过投射面到摄像机的距离来得到对应的投射面宽高(其中\\(aspectR=w/h\\))，于是有 \\[h = |n| \\tan{fovY/2}\\] \\[w = aspectR \\cdot h\\]","link":"/2021/03/25/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/"},{"title":"番剧点评：在2022年观看《凉宫春日》系列是怎样一种体验","text":"这是甲醛新开的一个坑，以后会不时更新当然也有可能因为想当懒狗/没有时间不再更新对自己最近在看/在追的番剧的点评以及感想。 前言 众所周知，我其实一开始并不是宅文化的受害者众之一before：二刺猿有什么好看的，但是自从上次看完京阿尼的《Clannad》之后，便一发不可收地上网开始寻找京都动画的其他优秀作品。毫无疑问的，所有的答案都指向这一部《凉宫春日的忧郁》下文简称为《忧郁》，于是我便在2022年开启了这场迟到了13年的追番。 小插曲：我本来一开始很想从06版开始看，但是经过多方查证之后发现06和09的差别仅仅在于顺序和09额外制作的几集，再加上现在网上流传（u2&amp;byrpt）的版本大多都是09版的，于是一口气把09版全部下了下来。 赏析 一开始，我以为《忧郁》是那种日常校园番剧，制作组也很好地卖了观众一个关子——以正常人的常识来说，这个世界上怎么可能存在外星人、未来人和超能力者？我们也能够很好地代入阿虚的角色，在SOS团的一个个成员向阿虚坦白自己身份的时候，第一反应当然是：怎么可能，这一定是他们故意搞怪来的（甚至笑出了声）。但是随着剧情的推进，才发现在这个世界里好像还真的存在这种非正常人类，不仅如此，他们的行动还全都是围绕着凉宫春日这个角色展开的，并且凉宫春日似乎真的有着让世界随自己意愿改变的能力。但是《忧郁》的剧情也不是那种超能力者大战的热血番，身为女主角的春日自始至终都被瞒在鼓里不知道自己的能力，也正因如此，她可以在毫无顾虑的情况下开展一场场大冒险。正如网友的评价，它是一部很全面的番剧，涵盖了：解密、科幻、悬疑等不同的题材，让每一个题材的爱好者都能在其中找到自己的那颗白菜，整体串起来又可以看到人物的成长，让人不得不赞叹谷川流的妙笔生花。 时间悖论 我个人算个半吊子科幻迷好歹也是高中晚自习不写作业看《基地》三部曲的人，而整部剧中让我最叹为观止的部分就是作者大量使用的“时间悖论”、在作品前半段埋下伏笔的同时，能在后面的剧情中将一个个伏笔展开填坑，这让作品的连贯性显得非常强的同时，能给读者相当强烈的情感、思维方面的冲击。 时间悖论是什么？我最早接触这个概念是在观看DC漫画《闪点悖论》的时候，闪电侠的设定是自己母亲在自己小的时候被人杀死，父亲含冤入狱，之后的剧情里发现这一切系能穿越时间的反派“逆闪电”一手造成的，但是逆闪电则是由闪电侠而生，到底是谁创造了谁？这就是一个典型的时间悖论，时间如同衔尾蛇一般，找不到进入这个循环的地方。 比如阿虚通过未来人学姐回到过去，穿着高中校服自称“约翰史密斯”，帮助初中生春日在操场上画下神秘符号，让春日对北高中的“约翰史密斯”念念不忘，选择到了阿虚所在的北高读高中，这一个闭环从哪一节开始？没有阿虚的穿越，春日就不会选择到北高读高中，没有了春日，也必定不会有阿虚和未来人学姐的接触，回到过去给春日留下“北高有一个有趣的‘约翰史密斯’”的印象，这就是作者设下的第一个时间悖论。 作者一开始就埋下了伏笔，没有阿虚的帮助也就没有《忧郁》的故事 同样的手法也出现在了《凉宫春日的消失》后文将简称为《消失》以及未被动画化的篇章中。这样的时间悖论在故事中出现，可以认为是人物之间的关系为“命运的安排”，从无到有地，被一双无形的大手给创造出来的，而《忧郁》中，这双大手当然就是春日那深不可测的神力，因为只要她没有遇见阿虚，那她在高中也永远会郁郁不得志参见《消失》中的春日下去，在对不平凡生活强烈的渴望中，无中生有地安排了相遇的这么一段历史。 凉宫春日为什么忧郁 虽然《凉宫春日的忧郁》只是前几集的标题，但实际上几乎每一集的故事都是围绕着“不要让凉宫同学不高兴”这一目的展开的。这里就不得不谈谈凉宫春日这个女主角了，看完整部剧，我对其的评价是：要不是阿虚脾气好，凉宫春日长得漂亮，这个故事从第一集就结束了 故事中，凉宫春日给我们展现出的形象是一个蛮不讲理、我行我素的普通高中女生，但是个人认为使其最与众不同的那一点并不是其天赐的“神力”，而是永远怀揣着“希望自己是这个世界的主角”的一颗心，自始至终，春日都在四处寻找神奇的事，希望证明地球是以自己为轴旋转的，但是同时又在不停地否定自己，认为这样的世界其实是根本不现实的正如古泉所说，凉宫同学虽然异想天开，但是还是有基本常识的，因此她需要一群人来支撑自己继续寻找自己是世界主角的证据，这群人正是剧中的SOS团。 凉宫春日其实只是单纯地希望世界上存在不可思议，但是理智终究占据上风，然而讽刺的是，其实她想找的那些奇人异士一直都在自己身边 阿虚作为SOS团里唯一一个真正意义上的普通人，却担负起了最大的责任，几乎所有的剧情都是由阿虚的行为在推动，虽然嘴上说着不想帮助春日搞这些莫名其妙的事，身体很诚实。一方面不可否认的，有阿虚对春日的欣赏吐槽一下，春日这个时代的作品真的很喜欢用傲娇的人设；另一方面，从《忧郁》的第一集阿虚的自述以及《消失》中阿虚内心自我挣扎的时候也明确的指出了，阿虚并不是不喜欢这样的生活，而是在认清了自己是个普通人的现实后，甘于接受自己的平庸但这并不代表他喜欢这种生活，而上高中正好遇上了能触动其埋藏在内心深处渴望的春日，同时春日也有带给他想要的不平凡学生生活的能力。春日其实也和阿虚一样，但是她无法接受世俗的观点而信念与现实的冲突，也正是其忧郁的来源。 京都动画的优秀制作 看完《忧郁》和《消失》之后，我又回去补了一下漫画，感叹是京都动画把《凉宫春日》系列推到了一个新的高度。 这TM是一个东西？是一个东西？ 之前看漫改虽然《忧郁》和《消失》本质上都是轻改动画，经常能出现原著粉把动画制作喷烂的情况，只能说现在的动画制作真的太廉价了，拿几张PPT都能让部分观众当作动画看得津津有味。但是京都动画对于《忧郁》和《消失》的改编可以说是神来之笔，在不改变原著优秀剧情的基础上可以穿插入许多精细制作的细节，篇幅原因此处不会一一列举。《漫无止境的八月》更是动画史上的经典，整整八集，完全相同的剧情，却以迥然不同的分镜制作第一次看的时候给我看傻了，以为自己下错片子了，虽然发布会上说希望大家体会到长门的心情，但是个人感觉更像是自己豪华制作团队的一次炫技让我写八段相同目的的代码都不一定能过查重，可惜的是，京都动画由于和文库的冲突，导致至今也再也没有出过一部《凉宫春日》系列的作品了，甚是可惜。 总结 《凉宫春日》系列让我们看到了在平凡生活中找寻神奇的凉宫春日，在这部动画里，阿虚就像我们观众一样，一边嘴上碎碎吐槽着，却又忍不住想要参与到这找寻奇妙的世界里。也许我们每个人心里都住着一个春日，在这个世俗的社会中找寻那属于自己的舞台。","link":"/2022/04/19/%E7%95%AA%E5%89%A7%E7%82%B9%E8%AF%84%EF%BC%9A%E5%9C%A82022%E5%B9%B4%E8%A7%82%E7%9C%8B%E3%80%8A%E5%87%89%E5%AE%AB%E6%98%A5%E6%97%A5%E3%80%8B%E7%B3%BB%E5%88%97%E6%98%AF%E6%80%8E%E6%A0%B7%E4%B8%80%E7%A7%8D%E4%BD%93%E9%AA%8C/"},{"title":"离散数学期末复习","text":"由于离散数学期中过于拉跨，专门开贴记录相关知识点。 关系 三个定理 如果\\(A_1\\subseteq A_2\\)则有\\(R(A_1)\\subset R(A_2)\\) \\(R(A_1\\cup A_2)=R(A_1)\\cup R(A_2)\\) 重点： \\(R(A_1\\cap A_2)\\subseteq R(A_1)\\cap R(A_2)\\) 整除关系 定义整除关系\\(a|b\\)为：\\(a\\)能整除\\(b\\)，如\\(3|6\\)，画哈塞图表示（哈塞图无向），则为上面为被整除的数，下面为除数。对于定义在集合\\(A=\\{1,3,6,9,15,45\\}\\)上的哈塞图如下： 在期中考试中错的很重一点是，对于偏序关系的大于、小于、上确界、下确界、极大值、极小值不清楚，那么对于偏序集合\\((A,|)\\) 覆盖关系(&lt;) \\(a|b \\rightarrow a&lt;b\\) 上确界(最小上界) 针对一个子集，对于一个集合\\(A\\)的子集\\(B=\\{1,3,9\\}\\)，若在\\(A\\)中能找到一个元素\\(a\\)，使得\\(\\forall b\\in B\\rightarrow b&lt;a\\)，且\\(a\\)小于其他所有的上界，本条件下，最小上界\\(LUB(B)=9\\) 下确界（最大下界） 同理于上确界，\\(GLB(B)=1\\) 极大值、最大值 极大值为不小于其他任何元素的元素，可以有多个；最大值为大于其他任何元素的元素，只能有一个或者不存在。对于\\(A\\)，极大值为\\(6,45\\)，最大值不存在。 格 偏序集中任意两个元素组成的集合均存在最小上界和最大下界的偏序集合称作一个格 群 四个渐进关系 名称 运算封闭 结合律 单位元 逆元 广群 groupoid √ × × × 半群 semigroup √ √ × × 含幺半群 monoid √ √ √ × 群 group √ √ √ √ 自由半群 群元素为字母表，运算为连接两个元素 子群 子代数 对于群\\(G\\)，\\(H\\)为\\(G\\)的子群，当且仅当\\(\\forall a,b\\in H\\rightarrow a^{-1}b\\in H\\)。 乘积代数 半群\\((S,*)\\)和\\((T,*')\\)，定义新的半群\\((S\\times T,*'')\\)，其中运算 \\(*''\\) 为 \\[(s_1, t_1)*''(s_2, t_2)=(s_1*s_2, t_1*'t_2)\\] 则\\(S\\times T\\)中的元素为\\(S\\)、\\(T\\)中元素组合后得到的二元组合\\((s,t)\\) 商代数 同余关系 对于广群 \\((S, *)\\) 有关系 \\(R\\) 为同余关系，当且仅当 \\(aRa'\\wedge bRb'\\rightarrow (a*b)R(a'*b')\\) PS：同余关系必定为一个等价关系，即满足自反、对称、传递。 商广群 由于同余关系将原广群划分为了多个不同的广群，因此我们称这样的划分得到的群为商广群 \\(G/R\\)，群的元素为划分得到的等价类。 同态&amp;同构 对于广群\\((S,*)\\)、\\((T,*')\\) ，有\\(f(s_1*s_2)=f(s_1)*'f(s_2)\\)若 对于\\(s_1,s_2\\in S\\)均成立，则称\\(f\\)为一个同态 (homomorphism) 映射 满足第一点且\\(f\\)为一个双射（同时单射和满射），则\\(f\\)为一个同构 (isomorphism) 映射。 满同态定理 对于满同态映射\\(f: S\\rightarrow T\\)，定义关系\\(R: aRb \\rightarrow f(a)=(b)\\)，则有： \\(R\\)为一个同余关系。 \\(g:S/R\\rightarrow T\\) 为一个同构关系。即 \\(R\\) 对 \\(S\\) 的划分得到的等价类的集合和 \\(T\\) 中元素满足一对一映射关系。 图 匹配 指边的子集中，两两顶点互不相同的集合。 最大匹配：边数最多的匹配集合 完备匹配：能将二部图\\((V_1,V_2), (V_1\\cup V_2=V)\\)中的所有顶点都匹配起来的匹配 图同构 两个图只有顶点的名字不同，其他完全相同。 必要不充分条件：两个图的图形不变量相同 通路与回路 连通图 仅针对无向图，如果无向图中的点两两连通，则说这个图是连通图。 强连通、弱连通 仅针对有向图，如果有向图中的点两两连通，则说这个图是强连通图；如果这个有向图不连通，但是与其对应的无向图连通，我们称这个图是弱连通的。 欧拉路径/回路 欧拉路径 包含所有边的一条通路 欧拉回路 包含所有边的一条回路 首先图必须要连通，然后 连通多重图有欧拉回路 \\(\\leftrightarrow\\) 顶点度数均为偶数 联通多重图有欧拉路径 \\(\\leftrightarrow\\) 仅有两个度为奇数的顶点。 使用 Fleury 算法构造欧拉路径 每次添加一条连接上一个选择的到的顶点，且不为割边（去掉后使得图不连通）的边，直到所有边都被添加。 哈密尔顿通路/回路 没有充要条件，pass 平面图以及着色 欧拉定理 对于连通的平面图，有\\(r=e-v+2\\)，其中，\\(r\\) 为由边划分得到的区域数量。 如果是有\\(k\\)个连通分量的平面图，则\\(r=k+e-v+1\\) 有\\(n\\)个顶点连通平面简单图\\(G\\)，有\\(e\\le 3n-6\\) 对于连通平面简单图，且\\(v\\ge3\\)、没有长度为 3 的回路，则有\\(e\\le 2v-4\\) Kuratowski 定理 一个图是平面图当且仅当它不含有任何可以通过\\(K_5\\)和\\(K_{3,3}\\)换点（将顶点换成边）得到的子图如下图。 图的着色 所有平面图都可以用五种颜色着色 有两种方法可以算出着色数，分别是朴素的算法以及着色多项式。 生成函数 一张表，慢慢背 ⑧","link":"/2020/12/26/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"程序化生成：Perlin噪声和Simplex噪声","text":"首先摘抄一段wiki上对于Perlin噪声的介绍： Perlin噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法。由于Perlin本人的失误，Perlin噪声这个名词现在被同时用于指代两种有一定联系的的噪声生成算法。这两种算法都广泛地应用于计算机图形学，因此人们对这两种算法的称呼存在一定误解。下文中的Simplex噪声和分形噪声都曾在严肃学术论文中被单独的称作Perlin噪声。 接下来，我将围绕生成一张2D噪声纹理为目标展开对于几种噪声生成方法的介绍。 Why 为什么我们需要这两种新的噪声生成方法？对于噪声的生成方法，最为平凡的办法当然是对于每个点取一个均匀分布的随机数，如，生成一个\\([0,1]\\)的uniform随机数，然后直接将其作为灰度值使用： 使用随机方法产生的白噪声，来自wiki 嗯，很符合我们对于噪声的想象，但是是不是缺了点什么？观察自然中的很多东西，比如山脉地形、云体等，我们可以将其高度、密度等分布视作是完全随机的，但是和上面的白噪声是有很大区别的，很明显的一个区别就是白噪声不够连续。Perlin指出，一个理想的噪声应该拥有以下的特征： 对旋转具有统计不变性； 能量在频谱上集中于一个窄带，即：图像是连续的，高频分量受限； 对变换具有统计不变性。 虽然在统计学上可能不比白噪声“随机”，但是这样的噪声很明显是更加真实且实用的。对于连续性，我们很容易想到对近邻进行采样的方法来实现，但是这是相当低效的：对近邻采样就意味着过程需要是串行执行的，对于图形学这种需要运行在GPU上的应用相当不友好，因此Perlin噪声便是我们的第一个选择。 Perlin噪声 Perlin噪声是以空间中的晶格为单位进行生成的，简单来说就是把空间划分为等长度/面积/体积的区块，然后针对每个区块进行运算：对于1D空间，晶格对x轴进行等宽的划分；对于2D空间，晶格将空间划分为一个个矩形；对于3D空间或者更高维的空间，则是（超）立方体。 接下来，对于每个晶格的顶点，我们随机分配一个梯度 gradient（如上图），梯度是一个向量，一维情况下则是一个斜率，相邻的晶格共享顶点的同时也会共享梯度。然后对于晶格里面的任意一个采样点，我们可以计算出晶格的各个顶点指向这个uv坐标的\\(\\delta\\)向量，对于2D的情况来说，就是矩形的四个顶点指向采样点的四个向量： 我们将每个顶点对应的delta向量和gradient向量点乘，得到采样点在四个顶点的噪声值，接下来就很简单了，用二维插值的方法，根据uv坐标计算出采样点的噪声值： 但是——等等，好像看起来不太对！每个晶格之间有很明显的分割痕迹，这是为什么？原因很简单，我们这里使用了线性的插值函数： \\[lerp(a, b, t) = a (1 - t) + bt\\] 这样的结果就是晶格与晶格之间的过渡不够平滑（很符合直觉），因此我们可以使用一个平滑过度的高次函数，Perlin在其最初的论文中提出的函数不够优秀，最终选用的函数为\\(6t^5 - 15t^4+10t^3\\) Perlin噪声的实现 这里我们选用了Taichi语言来实现柏林噪声，总结一下上面的流程，步骤如下： 将空间划分为等大小晶格 对于晶格的顶点分配梯度，共享的顶点在不同晶格之间共享相同的梯度 计算采样点相对晶格的位置，计算出delta向量 对应计算出顶点梯度和delta向量的点积结果 对点积结果根据采样点在晶格中的uv位置进行非线性插值，得到采样点的噪声值 首先我们定义图片大小为512x512，规定晶格大小为64，这样就把平面划分为了8x8的晶格： 12345window_size = (512, 512)pixels = ti.field(ti.f32)hl = ti.root.dense(ti.i, window_size[0]).dense(ti.j, window_size[1])gs = 64.0hl.place(pixels) 接下来，对于每个采样点，我们接收整数x, y作为坐标，计算出在晶格空间中的坐标\\([0, 8]\\times[0,8]\\)： 1234567u = (x + z) / gsv = (y + z) / gs# 晶格边界u0 = ti.floor(u, ti.i32)v0 = ti.floor(v, ti.i32)u1 = u0 + 1v1 = v0 + 1 接下来，我们需要针对晶格找到其对应的梯度，我们认为，对于二维的梯度，使用8个预分配的梯度值，然后每次随机地从这8个梯度值中取出一个即可，很明显如果顺序的反复取用很容易造成重复导致的人工痕迹，因此Perlin提出使用一个额外的转置数组 Permutation Array来伪随机地对于这几个梯度进行取用，只要转置数组打乱地足够好，那么就可以认为得到地梯度是近似于随机的。 12345678910111213141516171819202122232425ptable = ti.field(ti.i32, shape=512)ptable.from_numpy(np.array([151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180] * 2))grad_table = ti.Vector.field(2, ti.f32, shape=8)grad_table.from_numpy(np.array([(1, 2), (2, 1), (-1, 2), (-2, 1), (-1, -2), (-2, -1), (1, -2), (2, -1)]))@ti.funcdef grad(U, V): s = ptable[(ptable[U &amp; 255] + V) &amp; 255] return grad_table[s &amp; 7] grad函数接收两个整数作为随机种子，通过两次在转置数组中取值来得到梯度值，而我们需要每个晶格的顶点梯度保持一致，那么理所当然的输入的两个随机种子就是晶格顶点坐标，接下来就是把两个变量点乘得到结果，对四个点乘结果进行二维插值即可得到结果： 1234567891011121314@ti.funcdef dot_prod(u, v, ug, vg): delta = ti.Vector([u - ug, v - vg]) grad = grad(ug, vg).normalized() return ti.math.dot(delta, grad)@ti.funcdef perlin_noise(x, y, z): ... prod00 = dot_prod(u, v, u0, v0) prod01 = dot_prod(u, v, u1, v0) prod10 = dot_prod(u, v, u0, v1) prod11 = dot_prod(u, v, u1, v1) result = lerp2D(prod00, prod01, prod10, prod11, u - u0, v - v0) 最后，完整、可运行的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import taichi as tiimport numpy as npfrom time import timeti.init(arch=ti.cuda, debug=True)window_size = (512, 512)pixels = ti.field(ti.f32)# hierarchical layouthl = ti.root.dense(ti.i, window_size[0]).dense(ti.j, window_size[1])# flat layout# fl = ti.root.dense(ti.i, 400).dense(ti.j, 400)gs = 64.0hl.place(pixels)# len = 256ptable = ti.field(ti.i32, shape=512)ptable.from_numpy(np.array([151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180] * 2))grad_table = ti.Vector.field(2, ti.f32, shape=8)grad_table.from_numpy(np.array([(1, 2), (2, 1), (-1, 2), (-2, 1), (-1, -2), (-2, -1), (1, -2), (2, -1)]))minn = ti.field(ti.f32, shape=())@ti.funcdef smooth(t): return 6.0 * ti.pow(t, 5.0) - 15.0 * ti.pow(t, 4.0) + 10.0 * ti.pow(t, 3.0)@ti.funcdef lerp(v1, v2, t): g = 1.0 - smooth(t) return v1 * g + v2 * (1.0 - g)@ti.funcdef lerp2D(v00, v01, v10, v11, tu, tv): v0y = lerp(v00, v01, tu) v1y = lerp(v10, v11, tu) return lerp(v0y, v1y, tv)@ti.funcdef grad(U, V): s = ptable[(ptable[U &amp; 255] + V) &amp; 255] return grad_table[s &amp; 7]@ti.funcdef dot_prod(u, v, ug, vg): delta = ti.Vector([u - ug, v - vg]) grad = grad(ug, vg).normalized() return ti.math.dot(delta, grad)@ti.funcdef perlin_noise(x, y, z): u = (x + z) / gs v = (y + z) / gs u0 = ti.floor(u, ti.i32) v0 = ti.floor(v, ti.i32) u1 = u0 + 1 v1 = v0 + 1 prod00 = dot_prod(u, v, u0, v0) prod01 = dot_prod(u, v, u1, v0) prod10 = dot_prod(u, v, u0, v1) prod11 = dot_prod(u, v, u1, v1) result = lerp2D(prod00, prod01, prod10, prod11, u - u0, v - v0) return (result + 0.707) / 1.414@ti.kerneldef render(t: ti.f32): for x, y in pixels: pixels[x, y] = perlin_noise(x, y, t)if __name__ == '__main__': window = ti.ui.Window('Perlin Noise', window_size) canvas = window.get_canvas() t = 0.0 last_time = float(time()) while window.running: now_time = float(time()) delta_time = now_time - last_time t += delta_time last_time = now_time render(t * 100.0) canvas.set_image(pixels) window.show() 比较有趣的是，这样计算出来的Perlin并不是落在一个标准的范围中，我只是简单地认为其落在\\([-\\sqrt{2} / 2, \\sqrt{2} / 2]\\)的范围中，关于这个问题可以参考stackoverflow上的这个回答。实现的效果图如下： 很简单地，我们可以将Perlin噪声拓展到3D空间，并且将时间\\(t\\)作为第三维输入，这样就可以得到在空间中平滑变换的Perlin噪声。 Simplex噪声","link":"/2022/08/05/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90%EF%BC%9APerlin%E5%99%AA%E5%A3%B0%E5%92%8CSimplex%E5%99%AA%E5%A3%B0/"},{"title":"运筹学期末复习","text":"可作为复习资料打印 线性规划问题的单纯形法 线性规划的标准模型，下面给出一个例子 \\[\\max z = c_1x_1+c_2x_2+c_3x_3+c_4x_4\\] \\[ \\left\\{\\begin{array}{lr} a_{11}x_1+a_{12}x_2+a_{13}x_3+a_{14}x_4=b_1 &amp;\\\\ a_{21}x_1+a_{22}x_2+a_{23}x_3+a_{24}x_4=b_2 &amp;\\\\ a_{31}x_1+a_{32}x_2+a_{33}x_3+a_{34}x_4=b_3 &amp;\\\\ a_{41}x_1+a_{42}x_2+a_{33}x_3+a_{44}x_4=b_4 &amp;\\\\ x_1,x_2,x_3,x_4\\ge 0 \\end{array} \\right. \\] \\(\\vec b\\) 需要满足 \\(\\vec b \\ge 0\\) 单纯形法 对于一个线性规划问题如 可以作出以下的单纯形表 注：4800 改为 48000 单纯形表求解步骤 对原问题进行标准化 找到一个初始可行基\\(\\bar B\\)（即对应的系数矩阵为一个单位矩阵） 求出此时每列变量\\(x_i\\)对应的 \\(z_j = \\sum c_Ba_{ij}\\)，\\(\\sigma_j=c_j-z_j\\) 当\\(\\exist \\sigma_j &gt; 0\\)时，说明不是最优解，继续进入第四步，反之结束迭代，进入步骤8. 选出\\(\\max\\sigma_j\\)，选定该列对应的变量为换入变量 对于每一行，求得 \\(\\theta=b_j/\\max{a_{ij}}\\)，其中要求\\(a_{ij}&gt;0\\) 且 对应的列不能是基中的。选出\\(\\min\\theta\\)对应的一行的变量为换出变量 用高斯消元法，将对应的换入变量（方括号括中的）化为 1，对应列其余系数化为 0，得到新的表。 返回 步骤2. 最终解为表左边的基变量，对应的基变量的值为右方的\\(b\\) 有最优解 非基变量\\(\\sigma_j\\le 0\\)，基变量 \\(\\sigma_j=0\\) 唯一最优解 有最优解的情况下，所有非基变量的 \\(\\sigma_j&lt;0\\) 无穷多最优解 有最优解的情况下，存在非基变量的 \\(\\sigma_j=0\\) 无最优解 所有的系数 \\(a_{i,m+k}\\le 0\\)，且仍有一个非基变量的 \\(\\sigma_j&gt;0\\) 线性规划的对偶 P65 若原问题为 \\[\\max\\vec{c}^T\\vec x\\] \\[ \\left\\{\\begin{array}{lr} \\vec A \\vec x\\le \\vec b &amp;\\\\ \\vec x \\ge 0 \\end{array}\\right. \\] 则其对应的对偶问题为 \\[\\min\\vec{b}^T\\vec y\\] \\[ \\left\\{\\begin{array}{lr} \\vec A^T \\vec y\\ge \\vec c &amp;\\\\ \\vec y \\ge 0 \\end{array}\\right. \\] 可以得出：原问题的每个不等式对应对偶问题中的一个变量，其具体关系如下表 对偶定理 P68 对于一个问题及其对偶问题，有： 弱对偶定理 原问题的任意可行解的目标函数值是对偶问题的目标函数值的下界；反之，对偶问题的目标函数值为原问题的目标函数的上界 即 max 为 min 的下界，min 为 max 的上界 最优解存在性定理 若原问题和对偶问题均存在可行解，则它们必定存在最优解 无界解定理 若两个问题的都有可行解，且其中一个目标函数无界，则其另一个无可行解 强对偶定理 若其中一个有最优解，则另一个也有，且目标函数的值相等 互补松弛定理（P71） 将问题化为标准形式，将最优解\\(\\vec x^*\\)带入标准型中，求得松弛变量取值，再利用两个等式 \\[\\vec y^*\\vec x_S = 0\\] \\[\\vec y_S\\vec x^* = 0\\] 将求出的值代入对偶问题的标准型，再求出剩下的变量的值。 对偶单纯形法（P75） 对于标准形式的线性规划问题（\\(b\\)可小于等于 0），若\\(b\\)中不存在负数，则跳出；反之选择其中绝对值最大的，对应行为出基变量，计算\\(\\sigma_j/a_{ij}, a_{ij}&lt;0\\wedge \\sigma_j&lt;0\\)（如果所有\\(a_{ij}&gt;0\\)，则对偶问题没有可行解）比值最小的列对应变量为入基变量。 灵敏度分析 P79 资源系数 \\(\\vec b\\) 变化 P80 \\(\\vec x = B^{-1}(b+\\Delta b)\\ge 0\\)时，原最优解不变，其中\\(B^{-1}\\) 为原基变量的系数矩阵 已知资源系数的改变量\\(\\Delta b\\) 直接用上式求出新的\\(b\\)，用对偶单纯形法继续迭代。 价值系数 \\(\\vec c\\) 发生变化 P81 非基变量 若要原解不变，只需要对应系数\\(c_j\\)使得\\(\\sigma_j\\le0\\)即可保持原最优解不变。 基变量 需要保证所有非基变量的检验数\\(\\sigma_j\\le 0\\)。 如果题中有指出已经发生了变化，将变化的系数带入单纯形表中继续迭代即可。 技术系数 \\(A\\) 发生变化 P83 非基变量 对于该技术系数对应的列，左乘上一个\\(C_B\\)和原基变量的最终形表矩阵\\(B^{-1}\\)，即\\(c_BB^{-1}\\)，保证对应的\\(\\sigma_j\\le 0\\)即可保持原最优解不变。 基变量 见下表以及 P84 的详细讲解。 运输问题 P92 表上作业法（P96） 表的每个格中，单位运费写在左上角，右下角若为基变量则写\\(x_{ij}\\)即调用的数目，若为非基变量则写\\([\\sigma_{ij}]\\)（对应格的检验数）。 初始基可行解确定（最小元素法 P99） 每次选择费用最小的一个格，根据供应量在需求量减去对应的最大值，如果需求量减后为 0，则划去这列；如果对应的供应量减后为 0，则划去这列，反复迭代直到所有的需求都被满足。 检验最优性（闭回路法） P105 从一个非基变量格出发，画一个闭回路，要求回路上的其余所有顶点均为基变量，再将各个顶点从起点为 0 开始编号，对应非基变量的检验数\\(\\sigma = 偶数点运价和-奇数点运价和\\)，若所有检验数大于等于零，则对应的方案为最优方案。 无穷多最优解：非基变量检验数为 0 退化问题 找基可行解时，导致列和行同时饱和，同时划去这一行和这一列，除了交叉的点以外其余\\(x\\)取 0，导致得到了退化的基可行解 闭回路法调整时，有多个最小奇数顶点，只能取一个为换出变量，则得到了一个\\(x_{ij}=0\\)的退化解 方案调整 P109 选取负检验数中的最小者，作为换入变量 找闭回路并且编号，方法同上 找出奇数编号顶点中\\(x\\)最小的，作为调整量\\(\\theta\\)，作为换出变量 将回路中所有奇数点减去\\(\\theta\\)，偶数点加上\\(\\theta\\)，获得新的可行解 继续检验调整 指派问题 P129 已知每个人只能做一个工作，并且已知所有人做某个工作的费用，得到费用矩阵\\(C\\)，需要求使得费用最小（\\(\\min z\\)）的解零一矩阵 匈牙利算法 P132 对于给定费用矩阵 \\(C,\\quad(n=r(C))\\) 的指派问题 将费用矩阵\\(C\\)每行每列分别减去其对应行/列中的最小元素值得到\\(C'\\) 先逐行检验，若一行中只有一个未标记过或者只有一个没被叉标记的 0 元素，则将其括起，将其所在列的其他未标记 0 元素用叉X划去。重复进行直至每一行都没有被 0 标记或者有 2 个以上没有被标记的 0 列检验，同理 2. 将括了的(0)元素对应的解矩阵\\(X\\)中的元素置 1，其余元素置 0 步骤3结束后有可能会有如下几种情况 P133 每一行都有被括的 0，个数\\(m=n\\) 跳入步骤4 存在未被标记的零元素，但是其对应的行或者列中未被标记过的零元素都至少有两个 选择 0 元素少的行/列的某个 0 加括号 用叉划去其他 0 元素，再进行行、列检验 所有 0 均被标记，但是数量小于\\(n\\) P134（此处略过） 其他指派问题 最大化指派问题 P136 即需要求\\(\\max z\\)，可用矩阵中的最大元素减去矩阵中每个元素得到新矩阵，再使用匈牙利算法求解。 人数和事件数不等 P137 增加费用为 0 的人/事件，使用匈牙利算法求解 一个人可以同时做多件事 P138 将这个人的费用行复制一遍，再将人数和事件数调整至一致，使用匈牙利算法，求解得到的解矩阵为对应人需要做的多件事。 某事不能由某人去做 将这个人做这件事的费用取为一个足够大的 M 博弈论 两人有限零和博弈 游戏中有两个博弈者，每人均有有限个博弈策略可选，且两人的得失综合恒为 0。 博弈者分别有各自的策略集 \\(S_\\alpha=\\{\\alpha_1,\\alpha_2,...,\\alpha_n\\}\\) 和 \\(S_\\beta=\\{\\beta_1,\\beta_2,...,\\beta_m\\}\\)，则有博弈者的支付矩阵 \\[ A=\\begin{bmatrix} \\alpha_{11} &amp; ... &amp;\\alpha_{1n}\\\\ ... &amp; ... &amp; ...\\\\ \\alpha_{m1} &amp; ... &amp;\\alpha_{mn}\\\\ \\end{bmatrix} \\] 根据博弈者\\(\\alpha\\)的支付矩阵，我们可以将该博弈记作 \\(G=\\{S_\\alpha,S_\\beta;A\\}\\) 最优纯策略与纳什均衡 即让自己在的选择在对方从博弈空间中任选博弈时，自己的收益相等。 例：美女硬币 男/美女 美女正面 美女反面 男正面 3 -3 -2 2 男反面 -2 2 1 -1 设男出正面的概率为\\(x\\)，反面的概率为\\(1-x\\)；（女出正面的概率为 y，出反面的概率为\\(1-y\\)）。为使利益最大化，应该在对手出正面或反面的时候自己的收益相等（否则，对方就可以针对）： \\[3x + (-2)\\times(1-x)=(-2)\\times x + 1\\times(1-x)\\] 有 \\(x=3/8\\)；收益：\\(-1/8\\)。同理可列方程： \\[-3y+2(1-y) = 2y + (-1)\\times(1-y)\\] 有 \\(y=3/8\\)；收益：\\(1/8\\)。 最优混合策略 博弈者只能以一定的概率在策略集中随机地选择每个策略，则这种概率分布被称为混合策略。 令\\(x_i\\)，\\(y_i\\)为博弈者\\(S_\\alpha,S_\\beta\\)在各自策略集中选择\\(\\alpha_i,\\beta_i\\)的概率，则称\\(x=(x_1...x_m)\\)与\\(y=(y_1...y_m)\\)为两个博弈者的混合策略。 当\\(E(x^*,y^*)=v=\\min{\\max{E(xy)}}=\\max{min{E(xy)}}\\) 时，称\\(x^*,y^*\\)为博弈人的最优混合策略（若\\(v&lt;0\\)，则需要给收益矩阵每个元素加上\\(d\\)使得\\(v&gt;0\\)） 最优混合策略求解方法 可以列出以下两个不等式组 \\[ \\left\\{\\begin{array}{lr} \\sum_{i=1}^m\\alpha_{ij}x_i\\ge v\\qquad j=1,2,...,n &amp;\\\\ \\sum_{i=1}^m x_i=1 &amp;\\\\ x_i \\ge 0\\qquad i=1,2,...,m \\end{array} \\right. \\] \\[ \\left\\{ \\begin{array}{lr} \\sum_{j=1}^n\\alpha_{ij}y_j\\le v\\qquad i=1,2,...,m &amp;\\\\ \\sum_{j=1}^n y_i=1 &amp;\\\\ y_j \\ge 0\\qquad j=1,2,...,m \\end{array}\\right. \\] 将等式左右同时\\(x_i'=\\frac{x_i}{v}\\)，则可以得到线性规划 \\[ \\min S = \\sum^m\\_{i=1}x_i' \\] \\[ \\left\\{\\begin{array}{lr} \\sum_{i=1}^m\\alpha_{ij}x_i'\\ge v\\qquad j=1,2,...,n &amp;\\\\ x_i' \\ge 0\\qquad i=1,2,...,m \\end{array}\\right. \\] 和 \\[ \\min S' = \\sum^m\\_{i=1}y_i' \\] \\[ \\left\\{\\begin{array}{lr} \\sum_{j=1}^n\\alpha_{ij}y_i'\\le 1\\qquad i=1,2,...,m &amp;\\\\ y_i' \\ge 0\\qquad i=1,2,...,n \\end{array} \\right. \\] 例题，田忌赛马","link":"/2020/12/27/%E8%BF%90%E7%AD%B9%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"面试：腾讯IEG光子游戏客户端开发","text":"注：博主目前仅进行到一面，后续没有出结果，疑似凉经 2月份的时候估计回不了学校，考虑到下半年可能回不到学校，于是预计会在本地实习一段时间，第一个投递的岗位是腾讯IEG，找了一个学长-&gt;同学内推，本来一开始想的是在成都天美就地实习，但是貌似天美不太看得上我的简历（泪）；后面听学长说我的简历被深圳光子捞了，问我能不能去，想了想大概暑假是可以过去实习的，于是跳过了笔试，在3月8日进行了第一场面试，由于这是人生中第一场面试，所以在这里记录一下。 一面 一面面试官应该是一个做客户端渲染方面的腾讯员工，态度非常好（我的第一次面试，好评），主要是负责面试我图形和引擎方面的问题。首先根据我的工作意向提出了以下的问题： 考虑来深圳工作吗？实习之后考虑转正吗？ 可以暑假实习；实习之后会考虑转正。 随后根据我的简历问了下我的项目： 介绍自己做过的毛发渲染项目，觉得项目中比较有挑战性的问题有哪些？（PBR） 简单介绍了一下根据两篇论文实现的毛发bsdf；比较有挑战性的问题：预计算优化 有没有尝试把离线方法在实时引擎中实现？ 看过AMD的PPT，没有具体实现过 光线追踪中有没有遇到采样不足造成的瑕疵？如何解决？ 本质的方法：提高采样数；高效的方式：滤波（其实面试官想问采样不足造成的暗面亮度的问题，我没有领会到，但是现在回想起来可能是指的阴影贴图造成的失真） 大量mesh的情况下如何加速？ aabb、包围盒、bvh 介绍一下渲染管线 顶点输入、处理、顶点着色、面剔除、几何着色、图元组装、裁剪、深度测试、光栅化、片段着色、模板测试 渲染管线中的视锥体裁剪是发生在什么阶段？怎么处理的？ （我一开始把culling和tessellation搞混了），后面听到面试官提起这个概念后才说这个是发生在几何着色的组装之后，把视锥体外面不可见的部分进行剔除。 mvp矩阵的作用？分别是从什么空间变换到什么空间？ MVP是指model、view、projection三个矩阵，分别是模型矩阵，从模型空间变换到世界空间；视角矩阵，从世界空间变换到摄像机空间；投影矩阵，从摄像机空间变换到裁剪空间。 追问：MVP矩阵中哪些矩阵可以3x3实现，哪些4x3，哪些4x4 线性变换都可以由3x3的矩阵实现，例如model变换的rotate, scale；非线形变换需要由4x3或者4x4矩阵实现，例如model的translate、view的lookat可以由4x3实现，而projection在orthographic的时候可以4x3实现，在perspective的时候必须4x4实现（w分量会发生变化）。 透视除法的作用？ 把裁剪空间中的数据变换到NDC（标准设备空间）中，目的是标准化。 追问：哪些框架下z是0到1，哪些是-1到1？ DirectX是[0, 1]，OpenGL是[-1,1] 接下来就是我不会的了 了解过移动设备和高性能设备两种不同的渲染方式吗？ 我懵逼：前向渲染和延迟渲染？（面试官很给我面子地问我有没有了解过，我猜了这两种渲染方式，其实是想问立即渲染模式和瓦片式渲染） Unity、UE用过吗？知道怎么减少DrawCall吗？ 同样是不会，我只在很早的时候会用Unity干过一些简单的事情。 接下来面试官对我也了解得比较清楚了：图形学基础不错、没有学习过商业引擎、不了解图形硬件。 然后就是反问： 面试官：有没有什么是没有问到，你希望介绍的吗？ PBR？光照模型？ 离线渲染的项目已经足够了解了，不需要再额外问了。 C++？ 可能是之后别的同事来面 我：腾讯游戏客户端主要干啥？ 面试官很热情地给我介绍了他们的主要工作，主要就是关于各种调优，比如性能调优啊、画面调优、渲染调优之类的。 我：有独立的引擎部门吗？ 有，但是和客户端是独立的。 至此一面结束，大概也了解了自己知识在哪方面有缺陷，之后查漏补缺！ To be continue（如果进了复试）","link":"/2022/03/10/%E9%9D%A2%E8%AF%95%EF%BC%9A%E8%85%BE%E8%AE%AFIEG%E5%85%89%E5%AD%90%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"BSDF","slug":"BSDF","link":"/tags/BSDF/"},{"name":"PBR","slug":"PBR","link":"/tags/PBR/"},{"name":"Light transport","slug":"Light-transport","link":"/tags/Light-transport/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"csapp","slug":"csapp","link":"/tags/csapp/"},{"name":"考试","slug":"考试","link":"/tags/%E8%80%83%E8%AF%95/"},{"name":"FastAPI","slug":"FastAPI","link":"/tags/FastAPI/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"计算机图形学","slug":"计算机图形学","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"直线绘制","slug":"直线绘制","link":"/tags/%E7%9B%B4%E7%BA%BF%E7%BB%98%E5%88%B6/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"MIPS","slug":"MIPS","link":"/tags/MIPS/"},{"name":"流水线处理器","slug":"流水线处理器","link":"/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"NSCSCC2021","slug":"NSCSCC2021","link":"/tags/NSCSCC2021/"},{"name":"论文实现","slug":"论文实现","link":"/tags/%E8%AE%BA%E6%96%87%E5%AE%9E%E7%8E%B0/"},{"name":"论文阅读","slug":"论文阅读","link":"/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"离线渲染","slug":"离线渲染","link":"/tags/%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Siggraph Asia","slug":"Siggraph-Asia","link":"/tags/Siggraph-Asia/"},{"name":"渲染","slug":"渲染","link":"/tags/%E6%B8%B2%E6%9F%93/"},{"name":"Siggraph","slug":"Siggraph","link":"/tags/Siggraph/"},{"name":"ELO","slug":"ELO","link":"/tags/ELO/"},{"name":"电子竞技","slug":"电子竞技","link":"/tags/%E7%94%B5%E5%AD%90%E7%AB%9E%E6%8A%80/"},{"name":"胜率匹配","slug":"胜率匹配","link":"/tags/%E8%83%9C%E7%8E%87%E5%8C%B9%E9%85%8D/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"clangd","slug":"clangd","link":"/tags/clangd/"},{"name":"cuda","slug":"cuda","link":"/tags/cuda/"},{"name":"几何空间","slug":"几何空间","link":"/tags/%E5%87%A0%E4%BD%95%E7%A9%BA%E9%97%B4/"},{"name":"坐标系","slug":"坐标系","link":"/tags/%E5%9D%90%E6%A0%87%E7%B3%BB/"},{"name":"投影","slug":"投影","link":"/tags/%E6%8A%95%E5%BD%B1/"},{"name":"光栅渲染器","slug":"光栅渲染器","link":"/tags/%E5%85%89%E6%A0%85%E6%B8%B2%E6%9F%93%E5%99%A8/"},{"name":"Blender","slug":"Blender","link":"/tags/Blender/"},{"name":"布料模拟","slug":"布料模拟","link":"/tags/%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F/"},{"name":"gltf","slug":"gltf","link":"/tags/gltf/"},{"name":"usd","slug":"usd","link":"/tags/usd/"},{"name":"DCC","slug":"DCC","link":"/tags/DCC/"},{"name":"rust","slug":"rust","link":"/tags/rust/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"多媒体","slug":"多媒体","link":"/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"},{"name":"图像","slug":"图像","link":"/tags/%E5%9B%BE%E5%83%8F/"},{"name":"信号处理","slug":"信号处理","link":"/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"课程总结","slug":"课程总结","link":"/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"name":"路径追踪","slug":"路径追踪","link":"/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"name":"蒙特卡洛法","slug":"蒙特卡洛法","link":"/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%B3%95/"},{"name":"屏幕空间反射","slug":"屏幕空间反射","link":"/tags/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%8D%E5%B0%84/"},{"name":"离散数学","slug":"离散数学","link":"/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"最大流算法","slug":"最大流算法","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"数理统计","slug":"数理统计","link":"/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"凉宫春日","slug":"凉宫春日","link":"/tags/%E5%87%89%E5%AE%AB%E6%98%A5%E6%97%A5/"},{"name":"追番","slug":"追番","link":"/tags/%E8%BF%BD%E7%95%AA/"},{"name":"宅文化","slug":"宅文化","link":"/tags/%E5%AE%85%E6%96%87%E5%8C%96/"},{"name":"期末","slug":"期末","link":"/tags/%E6%9C%9F%E6%9C%AB/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"程序化生成","slug":"程序化生成","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"},{"name":"噪声","slug":"噪声","link":"/tags/%E5%99%AA%E5%A3%B0/"},{"name":"运筹学","slug":"运筹学","link":"/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"},{"name":"求职","slug":"求职","link":"/tags/%E6%B1%82%E8%81%8C/"},{"name":"游戏客户端开发","slug":"游戏客户端开发","link":"/tags/%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"计算机图形学","slug":"计算机图形学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"考试记录","slug":"考试记录","link":"/categories/%E8%80%83%E8%AF%95%E8%AE%B0%E5%BD%95/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"光传输","slug":"计算机图形学/光传输","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%85%89%E4%BC%A0%E8%BE%93/"},{"name":"几何学","slug":"计算机图形学/几何学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%87%A0%E4%BD%95%E5%AD%A6/"},{"name":"造轮子","slug":"造轮子","link":"/categories/%E9%80%A0%E8%BD%AE%E5%AD%90/"},{"name":"设计模式","slug":"C/设计模式","link":"/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"PBR","slug":"计算机图形学/PBR","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/PBR/"},{"name":"Misc","slug":"编程/Misc","link":"/categories/%E7%BC%96%E7%A8%8B/Misc/"},{"name":"csapp解题记录","slug":"csapp解题记录","link":"/categories/csapp%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"CUDA","slug":"编程/CUDA","link":"/categories/%E7%BC%96%E7%A8%8B/CUDA/"},{"name":"矩阵变换","slug":"计算机图形学/矩阵变换","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2/"},{"name":"DCC","slug":"计算机图形学/DCC","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/DCC/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"多媒体","slug":"计算机图形学/多媒体","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%A4%9A%E5%AA%92%E4%BD%93/"},{"name":"课程总结","slug":"课程总结","link":"/categories/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"name":"实时渲染","slug":"计算机图形学/实时渲染","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"},{"name":"离散数学","slug":"离散数学","link":"/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"GAMES101","slug":"计算机图形学/GAMES101","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/"},{"name":"番剧","slug":"番剧","link":"/categories/%E7%95%AA%E5%89%A7/"},{"name":"《凉宫春日》系列","slug":"番剧/《凉宫春日》系列","link":"/categories/%E7%95%AA%E5%89%A7/%E3%80%8A%E5%87%89%E5%AE%AB%E6%98%A5%E6%97%A5%E3%80%8B%E7%B3%BB%E5%88%97/"},{"name":"程序化生成","slug":"计算机图形学/实时渲染/程序化生成","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"},{"name":"求职","slug":"求职","link":"/categories/%E6%B1%82%E8%81%8C/"}],"pages":[{"title":"关于我","text":"我是谁 目前就读于北京邮电大学的一名2019级菜鸟本科生，爱好计算机图形学。 教育经历 北京邮电大学（Beijing University of Posts and Telecommunications） 本科 计算机学院（国家示范性软件学院） 2019-2023 作品集 HectorMIPS “龙芯杯”北京邮电大学2021年三等奖参赛作品HectorMIPS，一个高性能的双发射静态调度MIPS处理器。本人主要负责了流水线设计、开发和验证等工作。 Tiny Rasterizer 使用C++开发的软光栅化渲染器。 Marschner's Hair BSDF Model 基于Marschner和d'Eon的三篇论文，在Mitsuba离线路径追踪引擎中实现的人类头发bsdf模型。 OpenGL showcase OpenGL下实现的PBR(Physical Base Rendering) + MSM(Moment Shadow Map) + RSM(Reflective Shadow Map) + SSAO(Screen Space Ambient Occlusion)：OGLab。 Miscellaneous 使用ShaderToys构建的SDF RayMarching，使用smin函数实现物体融合的效果。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Resources","text":"渲染 Rendering 论文相关 Papers Siggraph论文大集合Ke-Sen Huang's Home Page 模型资源 Models Benedikt Bitterli's Rendering Resources：PBRT、Mitsuba相关的资源，提供者是Tungsten的作者 Sponza Atrium Sponza的文件 几个著名的3D测试场景与模型 By wolf96@CSDN McGuire Computer Graphics Archive 参考资料 References PBRT-v3：离线从入门到精通 LearnOpenGL：实时从新手到入门 Tone Mapping By Ignorance.moontree：讲解Tone Mapping的博客，同时我将这个博客archive了一份 Realtime Rendering：RTR系列丛书的官网 Inigo Quilez：主要提供了大量和Raymarching、SDF相关资料的网站，作者也是Raymarching方面的大神，除此以外也有很多几何、raytracing相关的资源 Microfacet BRDF By Simon","link":"/resources/index.html"}]}